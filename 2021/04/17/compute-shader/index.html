<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Compute Shader 简介 | 萤火之森</title><meta name="keywords" content="游戏开发,Shader"><meta name="author" content="猫冬"><meta name="copyright" content="猫冬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="做游戏的时候，我们经常要面对各种优化问题。DOTS 技术栈的出现提供了一种 CPU 端的多线程方案，那么我们是否也能将一些计算转到 GPU 上面，从而平衡好对 CPU 和 GPU 的使用呢？对我而言，以前使用 GPU 无非是通过写 vert&#x2F;frag shader、做好渲染相关的设置等操作，但实际上我们还能使用 GPU 的计算能力来帮我们解决问题。Compute Shader 就是我们跟 GPU">
<meta property="og:type" content="article">
<meta property="og:title" content="Compute Shader 简介">
<meta property="og:url" content="http://frankorz.com/2021/04/17/compute-shader/index.html">
<meta property="og:site_name" content="萤火之森">
<meta property="og:description" content="做游戏的时候，我们经常要面对各种优化问题。DOTS 技术栈的出现提供了一种 CPU 端的多线程方案，那么我们是否也能将一些计算转到 GPU 上面，从而平衡好对 CPU 和 GPU 的使用呢？对我而言，以前使用 GPU 无非是通过写 vert&#x2F;frag shader、做好渲染相关的设置等操作，但实际上我们还能使用 GPU 的计算能力来帮我们解决问题。Compute Shader 就是我们跟 GPU">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgscompute-shader-cover.jpg">
<meta property="article:published_time" content="2021-04-17T22:14:30.000Z">
<meta property="article:modified_time" content="2022-02-22T09:22:05.469Z">
<meta property="article:author" content="猫冬">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="Shader">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgscompute-shader-cover.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsfavicon.png"><link rel="canonical" href="http://frankorz.com/2021/04/17/compute-shader/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?91a6af339098c7b3314fd48d6640bbf8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-69634396-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-69634396-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Compute Shader 简介',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-22 09:22:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="萤火之森" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgshead.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.notion.so/frankorz/e9a64743c07743f08605f5df7cb57eaf"><i class="fa-fw far fa-sticky-note"></i><span> 公开笔记</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/pixel-art/"><i class="fa-fw fas fa-palette"></i><span> 像素画</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://img.frankorz.com/compute-shader-cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">萤火之森</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.notion.so/frankorz/e9a64743c07743f08605f5df7cb57eaf"><i class="fa-fw far fa-sticky-note"></i><span> 公开笔记</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/pixel-art/"><i class="fa-fw fas fa-palette"></i><span> 像素画</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Compute Shader 简介</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-17T22:14:30.000Z" title="发表于 2021-04-17 22:14:30">2021-04-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-22T09:22:05.469Z" title="更新于 2022-02-22 09:22:05">2022-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Compute Shader 简介"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>做游戏的时候，我们经常要面对各种优化问题。DOTS 技术栈的出现提供了一种 CPU 端的多线程方案，那么我们是否也能将一些计算转到 GPU 上面，从而平衡好对 CPU 和 GPU 的使用呢？对我而言，以前使用 GPU 无非是通过写 vert/frag shader、做好渲染相关的设置等操作，但实际上我们还能使用 GPU 的计算能力来帮我们解决问题。Compute Shader 就是我们跟 GPU 请求计算的一种手段。</p>
<p>本文将从并行架构开始，依次讲解一个最简单的 Compute Shader的编写、线程与线程组的概念、GPU 结构和其计算流水线，并讲解一个鸟群 Flocking 的实例，最后介绍 Compute Shader 的应用。全文较长，读者可以通过目录挑想看的看。</p>
<p>Compute Shader 也和传统着色器的写法十分不一样，写传统 Shader 写怕了的同学请放心~</p>
<span id="more"></span>
<h2 id="介绍-2">介绍</h2>
<p>当今的 GPU 已经针对单址或连续地址的大量内存处理（亦称为流式操作，streaming operation）进行了优化，这与 CPU 面向内存随机访问的设计理念则刚好背道而驰。再者，考虑到要对顶点与像素分别进行单独的处理，因此 GPU 现已经采用了大规模并行处理架构。例如，NVIDIA 公司开发的 “Fermi” 架构最多可支持 16 个流式多处理器（streaming multiprocessor, SM），而每个流式处理器又均含有 32 个 CUDA 核心，也就是共 512 个 CUDA 核心。</p>
<p>CUDA 与 OpenCL 其实就是通过访问 GPU 来编写通用计算程序的两组不同的 API。</p>
<p><img src="http://img.frankorz.com/cpu-gpu-compare.png" alt="CPU compare GPU"></p>
<p>现代的 CPU 有 4-8 个 Core，每个 Core 可以同时执行 4-8 个浮点操作，因此我们假设 CPU 有 64 个浮点执行单元，然而 GPU 却可以有上千个这样的执行单元。仅仅只是比较 GPU 和 CPU 的 Core 数量是不公平的，因为它们的职能不同，组织形式也不同。</p>
<p>显然，图形的绘制优势完全得益于 GPU 架构，因为这架构就是专为绘图而精心设计的。但是，一些非图形应用程序同样可以从 GPU 并行架构所提供的强大计算能力中受益。我们将 GPU 用于非图形应用程序的情况称为<strong>通用 GPU 程序设计</strong>（通用 GPU 编程。General Purpose GPU programming, GPGPU programming）。当然，并不是所有的算法都适合由 GPU 来执行，只有数据并行算法（data-parallel algorithm） 才能发挥出 GPU 并行架构的优势。也就是说，仅当拥有大量待执行相同操作的数据时，才最适宜采用并行处理。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>粒子系统是一个例子，我们可简化粒子之间的关系模型，使它们彼此毫无关联，不会相互影响，以此使每个粒子的物理特征都可以分别独立地计算出来。</p>
<p>对于 GPGPU 编程而言，用户通常需要将计算结果返回 CPU 供其访问。这就需将数据由显存复制到系统内存，虽说这个过程的速度较慢（见下图），但是 GPU 在运算时所缩短的时间相比却是微不足道的。 针对图形处理任务来说，我们一般将运算结果作为渲染流水线的输入，所以无须再由 GPU 向 CPU 传输数据。例如，我们可以用计算着色器（Compute Shader）对纹理进行模糊处理（blur），再将着色器资源视图（shader resource view，DirectX 的概念），与模糊处理后的纹理相绑定，以作为着色器的输入。</p>
<p><img src="http://img.frankorz.com/cpu-gpu-speed.png" alt="CPU 与 GPU 的数据传输"></p>
<p>计算着色器虽然是一种可编程的着色器，但 Direct3D 并没有将它直接归为渲染流水线中的一部分。虽然如此，但位于流水线之外的计算着色器却可以读写 GPU 资源。从本质上来说，计算着色器能够使我们访问 GPU 来实现数据并行算法，而不必渲染出任何图形。正如前文所说，这一点即为 GPGPU 编程中极为实用的功能。另外，计算着色器还能实现许多图形特效——因此对于图形程序员来说，它也是极具使用价值的。前面提到，由于计算着色器是 Direct3D 的组成部分，也可以读写 Direct3D 资源，由此我们就可以将其输出的数据直接绑定到渲染流水线上。</p>
<p><img src="http://img.frankorz.com/compute-shader-pipeline.png" alt="计算着色器并非渲染流水线的组成部分，但是却可以读写GPU 资源。而且计算着色器也可以参与图形的渲染或单独用于 GPGPU 编程"></p>
<h2 id="最简单的-Compute-Shader">最简单的 Compute Shader</h2>
<p>现在我们来看看一个最简单的 Compute Shader 的结构。</p>
<p>Unity 右键 → Create → Shader → Compute Shader 就可以创建一个最简单的 Compute Shader。</p>
<p>Compute Shader 文件扩展名为 .compute，它们是以 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/SL-ShadingLanguage.html">DirectX 11 样式 HLSL 语言</a>编写的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma kernel CSMain</span></span><br><span class="line"></span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line"></span><br><span class="line">[numthreads(<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="type">void</span> CSMain(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 为了演示，我把模板中下面这行改了</span></span><br><span class="line">    Result[id.xy] = float4(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 1 行：一个计算着色器资源文件必须包含至少一个可以调用的 compute kernel，实际上这个 kernel 对应的就是一个函数，该函数由 <code>#pragma</code> 指示，名字要和函数名一致。一个 Shader 中可以有多个内核，只需定义多个 <code>#pragma kernel functionName</code> 和对应的函数即可，C# 脚本可以通过 kernel 的名字来找到对应要执行的函数（ <code>shader.FindKernel(functionName)</code>）。</p>
<p>第 3 行： RWTexture2D 是一种可供 Compute Shader 读写的纹理，C# 脚本可以通过 <code>SetTexture()</code> 设置一个可读写的 RenderTexture 供  Compute Shader 修改像素颜色。其中 RW 代表可读写。</p>
<p>第 5 行：<code>numthreads</code> 设置线程组中的线程数。组中的线程可以被设置为 1D、2D 或 3D 的网格布局。线程组和线程的概念下文会提到。</p>
<p>第 6 行：CSMain 为函数名，需要和 pragma 定义的 kernel 名一一对应。一个函数体代表一个线程要执行的语句，传进来的 <code>SV_DispatchThreadID</code> 是三维的线程 id，下文会提到。</p>
<p>第 9 行：根据当前线程 id 索引到可读写纹理对应的像素，并设置颜色。</p>
<p>C# 脚本这边</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitShader</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    _image = GetComponent&lt;Image&gt;();</span><br><span class="line">    _kernelIndex = computeShader.FindKernel(<span class="string">&quot;CSMain&quot;</span>);</span><br><span class="line">    <span class="built_in">int</span> width = <span class="number">1024</span>, height = <span class="number">1024</span>;</span><br><span class="line">    _rt = <span class="keyword">new</span> RenderTexture(width, height, <span class="number">0</span>) &#123;enableRandomWrite = <span class="literal">true</span>&#125;;</span><br><span class="line">    _rt.Create();</span><br><span class="line"></span><br><span class="line">    _image.material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, _rt);</span><br><span class="line">    computeShader.SetTexture(_kernelIndex, <span class="string">&quot;Result&quot;</span>, _rt);</span><br><span class="line">    computeShader.Dispatch(_kernelIndex, width / <span class="number">8</span>, height / <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 4 行：一个 Compute Shader 可能有多个 Kernel，这里根据名字找到需要的 KernelIndex，这样脚本才知道要把数据送给哪一个函数运算。</p>
<p>第 6、7 行：创建一个支持随机读写的 <code>RenderTexture</code> 。</p>
<p>第 10 行：为 Compute Shader 设置要读写的纹理。</p>
<p>第 11 行：设置好要执行的线程组的数量，并开始执行 Compute Shader。线程组数量的设置下文会提到。</p>
<p>将 Compute Shader 在 Inspector 赋值给脚本，然后将脚本挂在一个有 Image 组件的 GameObject 下，就能看到蓝色的图片。</p>
<p><img src="http://img.frankorz.com/simple-compute-shader-demo.png" alt="简单的着色器示例"></p>
<p>到现在我们应该大概明白了：</p>
<ul>
<li>kernel 函数里面执行的是一个线程的要执行的逻辑。</li>
<li>我们需要设置线程组的数量（Dispatch）、和线程组内线程的数量（numthreads）。</li>
<li>我们可以为 Compute Shader 设置纹理等可读写资源。</li>
</ul>
<p>那么什么是线程组和线程呢？我们又该如何设置数量？</p>
<h2 id="如何划分工作：线程与线程组">如何划分工作：线程与线程组</h2>
<p>在 GPU 编程的过程中，根据程序具体的执行需求，可将 <strong>线程</strong> 划分为由 <strong>线程组（thread group）</strong> 构成 的网格（grid）。</p>
<p><code>numthread</code> 和 <code>Dispatch</code> 的三维 Grid 的设置方式只是方便逻辑上的划分，硬件执行的时候还会把所有线程当成一维的。因此 <code>numthread(8, 8, 1)</code> 和 <code>numthread(64, 1, 1)</code> 只是对我们来说索引线程的方式不一样而已，除外没区别。</p>
<h3 id="线程组构成的-3D-网格">线程组构成的 3D 网格</h3>
<p>下图是 <code>Dispatch(5,3,2)</code>， <code>numthreads(10,8,3)</code> 时的情况。</p>
<p>注意下图 Y 轴是 DirectX 的方向，向下递增，而 Compute Shader 中 Y 轴是相反的，向上递增，这里参考网格内的结构和线程组与线程的关系即可。</p>
<p><img src="http://img.frankorz.com/dx-grid-of-thread-group.png" alt="线程组 3D 网格"></p>
<p>上图中还显示了 <code>SV_DispatchThreadID</code> 是如何计算的。</p>
<p>不难看出，我们能够根据需求定义出不同的线程组布局。例如，可以定义一个具有 X 个线程的单行线程组 <code>[numthreads(X, 1, 1)]</code> 或内含 Y 个线程的单列线程组 <code>[numthreads(1, Y, 1)]</code>。</p>
<p>还可以通过将维度 z 设为 1 来定义规模为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>×</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X × Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 的 2D 线程组，形如 <code>[numthreads(X, Y, 1)]</code>。我们应结合所遇到的具体问题来选择适当的线程组布局。</p>
<p>例如当我们处理 2D 图像时，需要让每一个线程单独处理一个像素，就可以定义 2D 的线程组。假设我们 <code>numthreads</code> 设置为 (8, 8, 1)，那么一个线程组就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8×8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 个线程，能处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8×8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span> 的像素块（内含 64 个像素点）。</p>
<p>那么如果我们要处理一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>×</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">texResolution × texResolution</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">eso</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">eso</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span> 分辨率的纹理，那么需要多少个线程组呢？</p>
<p>x 和 y 方向都需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>R</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">/</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">texResolution / 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">eso</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord">/8</span></span></span></span> 个线程组。</p>
<img class="inline-img" src="http://img.frankorz.com/thread-group-explain.png" style="height:250px"/>
<!-- ![Thread Group of image](http://img.frankorz.com/thread-group-explain.png) -->
<p>可以通过线程组来划分要处理哪些像素块（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8×8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>）</p>
<p><img src="http://img.frankorz.com/thread-group-explain-1.png" alt="线程组解释"></p>
<p><img src="http://img.frankorz.com/thread-group-explain-2.png" alt="线程组解释"></p>
<p>numthreads 有最大线程限制，具体查阅不同平台的文档：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/direct3dhlsl/sm5-attributes-numthreads">numthreads</a> 。</p>
<p>前面介绍了如何设置线程组和线程的数量，现在介绍线程组和线程在硬件的运行形式。</p>
<h3 id="线程组的-GPU-之旅">线程组的 GPU 之旅</h3>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/Fermi-c97604af538148cf96805b7b14ce332e">Fermi 架构</a></p>
<p><a target="_blank" rel="noopener" href="https://www.notion.so/Ampere-3e00af14b1fb455db5b0a928a26d65aa">Ampere 架构</a></p>
<p>我们知道 GPU 会有上千个“核心”，用 NVIDIA 的说法就是 CUDA Core。</p>
<ul>
<li><strong>SP</strong>：最基本的处理单元，streaming processor，也称为 CUDA core。最后具体的指令和任务都是在 SP 上处理的。GPU 进行并行计算，也就是很多个 SP 同时做处理。我们所说的几百核心的 GPU 值指的都是 SP 的数量；</li>
<li><strong>SM</strong>：多个 SP 加上其他的一些资源组成一个 streaming multiprocessor。也叫 GPU 大核，其他资源如：warp scheduler，register，shared memory 等。SM 可以看做 GPU 的心脏（对比 CPU 核心），register 和 shared memory 是 SM 的稀缺资源。CUDA 将这些资源分配给所有驻留在 SM 中的 threads。因此，这些有限的资源就使每个 SM 中 active warps 有非常严格的限制，也就限制了并行能力。</li>
</ul>
<p>这些核心被组织在流式多处理器（streaming multiprocessor, SM）中，一个线程组运行于一个多处理器（SM）之上。每一个核心同一时间可以运行一个线程。</p>
<p>流式多处理器（streaming multiprocessor, SM）是 Nvidia 的说法，AMD 对应的单元则是 Compute Unit。</p>
<p>因此，对于拥有 16 个 SM 的 GPU 来说，我们至少应将任务分解为 16 个线程组，来让每个多处理器都充分地运转起来。但是，要获得更佳的性能，我们还应当令每个多处理器至少拥有两个线程组，使它能够切换到不同的线程组进行处理，以连续不停地工作（线程组在运行的过程中可能会发生停顿，例如，着色器在继续执行下一个指令之前会等待纹理的处理结果，此时即可切换至另一个线程组）。</p>
<p>SM 会将它从 Gigathread 引擎（NVIDIA 技术，专门管理整个流水线）那收到的大线程块，拆分成许多更小的堆，每个堆包含 32 个线程，这样的堆也被称为：<strong>warp</strong> (AMD 则称为 <strong>wavefront</strong>)。多处理器会以 SIMD32 的方式（即 32 个线程同时执行相同的指令序列）来处理 warp，每个 CUDA 核心都可处理一个线程。</p>
<p>“Fermi” 架构中的每个多处理器都具有 32 个 CUDA 核心。</p>
<p>每一个线程组都会被划分到一个 Compute Unit 来计算，线程组中的线程由 Compute Unit 中的 SIMD 部分来执行。<br>
如果我们定义 <code>numthreads(8, 2, 4)</code>，那么每个线程组就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">8×2×4=64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> 个线程，这一整个线程组会被分成两个 warp，调度到单个 SIMD 单元计算。</p>
<p><img src="https://img-blog.csdnimg.cn/20200126195846919.gif" alt="Memory Stall（内存延迟）"></p>
<p>单个 SM 处理逐个 warp，当一个 warp 暂时需要等待数据的时候，就可以先换其他 warp 继续执行。</p>
<h3 id="如何设置好线程组的大小">如何设置好线程组的大小</h3>
<p>我们应当总是将线程组的大小设置为 <strong>warp 尺寸的整数倍</strong>。让 SM 同时容纳多个 warp，能够以防一些情况。例如有时候为了等待某些数据就绪，你不得不停下来。比如说，我们需要通过法线纹理贴图来计算法线光照，即使该法线纹理已经在 Cache 中了，访问该资源仍然会有所耗时，而如果它不在 Cache 中，那就更加耗时了。用专业术语讲就是 <strong>Memory Stall（内存延迟）</strong>。与其什么事情也不做，不如将当前的 Warp 换成其它已经准备就绪的 Warp 继续执行。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p><img src="http://img.frankorz.com/thread-group-size-talk.png" alt="Dispatch/Thread Group SIze Heuristics"></p>
<p>上图来自：<a target="_blank" rel="noopener" href="https://channel9.msdn.com/Blogs/gclassy/DirectCompute-Lecture-Series-210-GPU-Optimizations-and-Performance">DirectCompute Lecture Series 210: GPU Optimizations and Performance</a></p>
<blockquote>
<p>NVIDIA 在 Maxwell 更改了 SM 的组织方式，即 SMM——全新的 SM 架构。每个 SM 分为四个独立的处理块，每个处理块具备自己的指令缓冲区、调度器以及 32 个 CUDA 核心。因此 Maxwell 中可以同时运行 4 个以上的 Warp，实际上，在 GTC2013 大会上的一个 CUDA 优化视频里讲到，在常用 case 中推荐使用 30 个以上的有效 Warp，这样才能确保 Pipeline 的满载利用率。<br>
—— <a target="_blank" rel="noopener" href="http://www.ece.rice.edu/~gw2/">Guohui Wang</a></p>
</blockquote>
<p>NVIDIA 公司生产的图形硬件所用的 warp 单位共有 32 个线程。而 ATI 公司采用的 “wavefront” 单位则具有 64 个线程，且建议为其分配的线程组大小应总为 wavefront 尺寸的整数倍。另外，值得一提的是，不管是 warp 还是 wavefront，它们的大小在未来几代中都有可能发生改变。</p>
<p>总之，每个 SM 的操作度是 warp，但是每个 SM 可以同时处理多个 warp。然后因为有内存等待（memory stall）的问题，同一个 thread block 有可能需要等待内存才做，因此可以使用多个线程组交叉运行。warp 对我们是不可见和不可编程的，我们可编程的只有线程组。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<p>还可以参考 GPU Open 中 <a target="_blank" rel="noopener" href="https://gpuopen.com/performance/#shaders">Compute Shader 部分</a>。</p>
<h2 id="GPU-Compute-Unit">GPU Compute Unit</h2>
<p>接下来我们看一下 GPU 内部的结构，这里的内容来自 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=0DLOJPSxJEg">Compute Shaders: Optimize your engine using compute / Lou Kramer, AMD</a>，<a target="_blank" rel="noopener" href="https://twitter.com/lou_auroyup">Lou Kramer</a> 以 AMD 的 GCN 架构为例，介绍了 GPU 大体的结构。</p>
<p>这里 GCN 就是一个 Compute Unit，Vega 64 显卡有 64 个 Compute Unit。</p>
<p><img src="http://img.frankorz.com/gpu-talk-1.png" alt="gpu-talk-1"></p>
<p>GCN 有 4 个 SIMD-16 单元（即 16 个线程同时执行相同的指令序列）。</p>
<p><img src="http://img.frankorz.com/gpu-talk-2.png" alt="gpu-talk-2"></p>
<h3 id="线程间交流">线程间交流</h3>
<h4 id="多个线程组间的交流">多个线程组间的交流</h4>
<p>上面提到，线程并不能访问其他组中的共享内存。如果线程组需要互相交流，那么就需要 L2 cache 来支持。但是 L2 cache 性能肯定会有折扣，因此我们要保证组间的交流尽可能少。</p>
<p><img src="http://img.frankorz.com/gpu-talk-3.png" alt="gpu-talk-3"></p>
<h4 id="单个线程组内的交流">单个线程组内的交流</h4>
<p>如果单个线程组内线程需要互相交流，则需要 Local Data Share (LDS) 来完成。</p>
<p><img src="http://img.frankorz.com/gpu-talk-4.png" alt="gpu-talk-4"></p>
<p>LDS 会被其他着色阶段（shader stage）使用，例如像素着色器就需要 LDS 来插值。但是 Compute Shader 的用途和传统着色器不一样，不是必须要 LDS，因此我们可以随意地使用 LDS。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">groupshared <span class="type">float</span> data[<span class="number">8</span>][<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">[numthreads(<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="type">void</span> main(<span class="type">ivec3</span> <span class="keyword">index</span> : SV_GroupThreadID)</span><br><span class="line">&#123;</span><br><span class="line">  data[<span class="keyword">index</span>.x][<span class="keyword">index</span>.y] = <span class="number">0.0</span>;</span><br><span class="line">  GroupMemoryBarrierWithGroupSync();</span><br><span class="line">  data[<span class="keyword">index</span>.y][<span class="keyword">index</span>.x] += <span class="keyword">index</span>.x;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要组内共享的变量前加 <code>groupshared</code> ，同时为了保证其他线程也能读到数据，我们也需要通过 Barrier 来保证他们读的时候 LDS 里面有需要的数据。</p>
<p>LDS 比 L1 cache 还快！</p>
<h3 id="Vector-Register-和-Scalar-Register">Vector Register 和 Scalar Register</h3>
<p>如果有些变量是线程独立的，我们称之为 “non-uniform” 变量。（如果一个线程组内有 64 个线程，就要存 64 份数据）</p>
<p>如果有些变量是线程间共享的的，我们称之为 “uniform” 变量，例如线程组 id 是组内每个线程都一样的。（每个线程组内只存 1 份数据）</p>
<p>“non-uniform” 变量会被储存到 Vector Register（VGPR, vector general purpose register）中。</p>
<p>“uniform” 变量会被储存到 Scalar Register（SGPR, scalar general purpose register）中。</p>
<p><img src="http://img.frankorz.com/gpu-talk-5.png" alt="gpu-talk-5"></p>
<p>如果用了过多 “non-uniform” 变量导致 Vector Register 装不下，就会导致分配给 SIMD 的线程组数量降低。</p>
<h3 id="与传统着色器执行流程的异同">与传统着色器执行流程的异同</h3>
<h4 id="Vert-Frag-Shader">Vert-Frag Shader</h4>
<ol>
<li>
<p>首先 Command Processor 会收集并处理所有命令，发送到 GPU，并告知下一步要做什么。</p>
</li>
<li>
<p><code>Draw()</code> 命令发送后，Command Processor 告知 Graphics Processor 要做的事情。</p>
<p>我们可以将 Graphics Processor 看作是输入装配器（Input Assembler）的硬件对应的部分。</p>
</li>
<li>
<p>然后类似于顶点着色器这些就会被送到 Compute Unit 去计算，处理完会到 Rasterizer (光栅器)，并返回处理好的像素到 Compute Unit 执行像素着色（Pixel shader）。</p>
</li>
<li>
<p>最后才会输出到 RenderTarget 。</p>
</li>
</ol>
<p>下图中，AMD 显卡架构中的 Compute Unit 相当于 nVIDIA GPUs 中的流式多处理器（streaming multiprocessor, SM）。</p>
<p><img src="http://img.frankorz.com/gpu-talk-6.png" alt="gpu-talk-6"></p>
<h4 id="Compute-Shader">Compute Shader</h4>
<ol>
<li>首先 Command Processor 仍会收集并处理所有命令，发送到 GPU。</li>
<li>我们不需要传数据到 Graphics Processor，因为这不是一个 Graphics Command，而是直接传到 Compute Unit。</li>
<li>Compute Unit 开始处理 Compute Shader，输入可以有 constants 和 resources（对应 DirectX 的 Resource 可以绑定到渲染管线的资源，例如顶点数组等），输出可以有 writable resources（UAV, Unordered Access View 能被着色器写入的资源视图）。</li>
</ol>
<h3 id="总结-13">总结</h3>
<p>因此，如果我们用了 Compute Shader，<strong>可以不通过渲染管线，跳过 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Render_output_unit">Render Output</a>，使用更少硬件资源</strong>，利用 GPU 来完成一些渲染不相关的工作。</p>
<p><img src="http://img.frankorz.com/gpu-talk-7.png" alt="gpu-talk-7"></p>
<p>此外，Compute Shader 的流水线<strong>需要的信息也更少</strong>。</p>
<p><img src="http://img.frankorz.com/gpu-talk-8.png" alt="gpu-talk-8"></p>
<h2 id="Boids-示例">Boids 示例</h2>
<p>讲完了理论，这里来看看我们在 Unity 中使用 Compute Shader 来做一个鸟群（Boids）的 demo。</p>
<p>群落算法可以参考：<a target="_blank" rel="noopener" href="https://www.red3d.com/cwr/boids/">Boids (Flocks, Herds, and Schools: a Distributed Behavioral Model)</a></p>
<p>代码示例地址：<a target="_blank" rel="noopener" href="https://github.com/Latias94/FlockingComputeShaderCompare">Latias94/FlockingComputeShaderCompare</a></p>
<p>群落算法简单来讲，就是模拟生物群落的自组织特性的移动。</p>
<p><a target="_blank" rel="noopener" href="https://www.red3d.com/cwr/index.html">Craig Reynolds</a> 在 1986 年对诸如鱼群和鸟群的运动进行了建模，提出了三点特征来描述群落中个体的位置和速度：</p>
<ol>
<li>排斥（separation）：每个个体会避免离得太近。离得太近需要施加反方向的力使其分开。</li>
<li>对齐（Alignment）：每个个体的方向会倾向于附近群落的平均方向。</li>
<li>凝聚（Cohesion）：每个个体会倾向于移动到附近群落的平均位置。</li>
</ol>
<p>在这个示例中，我们可以将每一只鸟的位置和方向用一个线程来计算，Compute Shader 负责遍历这只鸟的周围鸟的信息，计算出这只鸟的平均方向和位置。C# 脚本则负责每一帧传入凝聚（Cohesion）的位置、经过的时间，再从 Compute Shader 获取每一只鸟的位置和朝向，设置到每一只鸟的 Transform 上。</p>
<h3 id="设置数据">设置数据</h3>
<p>文章开头的例子中，脚本给 Shader 设置了 <code>RWTexture2D&lt;float4&gt;</code> ，让 Compute Shader 能直接在 Render Tecture 设置颜色。</p>
<p>对于其他类型的数据，我们首先要定义一个结构（Struct），再通过 <code>ComputeBuffer</code>  与 Compute Shader 交流数据。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlockingGPU.cs</span></span><br><span class="line"><span class="keyword">struct</span> Boid</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 position;</span><br><span class="line">    <span class="keyword">public</span> Vector3 direction;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlockingGPU</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ComputeShader shader;</span><br><span class="line">    <span class="keyword">private</span> Boid[] _boidsArray;</span><br><span class="line">    <span class="keyword">private</span> GameObject[] _boids;</span><br><span class="line">    <span class="keyword">private</span> ComputeBuffer _boidsBuffer;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _kernelHandle = shader.FindKernel(<span class="string">&quot;CSMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">uint</span> x;</span><br><span class="line">        <span class="comment">// 获取 Compute Shader 中定义的 numthreads</span></span><br><span class="line">        shader.GetKernelThreadGroupSizes(_kernelHandle, <span class="keyword">out</span> x, <span class="keyword">out</span> _, <span class="keyword">out</span> _);</span><br><span class="line">        _groupSizeX = Mathf.CeilToInt(boidsCount / (<span class="built_in">float</span>) x);</span><br><span class="line">        <span class="comment">// 塞满每个线程组，免得 Compute Shader 中有线程读不到数据，造成读取数据越界</span></span><br><span class="line">        _numOfBoids = _groupSizeX * (<span class="built_in">int</span>) x;</span><br><span class="line"></span><br><span class="line">        InitBoids();</span><br><span class="line">        InitShader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">InitBoids</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化 _Boids GameObject[]、_boidsArray Boid[]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitShader</span>()</span></span><br><span class="line">    &#123;   <span class="comment">// 定义大小，鸟的数量和每个鸟结构的大小，一个 Vector3 就是 3 * sizeof(float)</span></span><br><span class="line">        <span class="comment">// 10000 只鸟，每只占6 * 4 bytes，总共也就占 0.234mib GPU 显存 </span></span><br><span class="line">        _boidsBuffer = <span class="keyword">new</span> ComputeBuffer(_numOfBoids, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="built_in">float</span>));</span><br><span class="line">        _boidsBuffer.SetData(_boidsArray); <span class="comment">// 设置结构数组到 Compute Buffer 中</span></span><br><span class="line">        <span class="comment">// 设置 buffer 到 Compute Shader，同时设置要调用的计算的函数 Kernel</span></span><br><span class="line">        shader.SetBuffer(_kernelHandle, <span class="string">&quot;boidsBuffer&quot;</span>, _boidsBuffer);</span><br><span class="line">        shader.SetFloat(<span class="string">&quot;boidSpeed&quot;</span>, boidSpeed); <span class="comment">// 设置其他常量</span></span><br><span class="line">        shader.SetVector(<span class="string">&quot;flockPosition&quot;</span>, target.transform.position);</span><br><span class="line">        shader.SetFloat(<span class="string">&quot;neighbourDistance&quot;</span>, neighbourDistance);</span><br><span class="line">        shader.SetInt(<span class="string">&quot;boidsCount&quot;</span>, boidsCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_boidsBuffer != <span class="literal">null</span>)</span><br><span class="line">        &#123;    <span class="comment">// 用完主动释放 buffer</span></span><br><span class="line">            _boidsBuffer.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取数据">获取数据</h3>
<p>在开头最简单的 Compute Shader 一节中，我介绍了需要 <code>Dispatch</code> 去执行 Compute Shader 的 Kernel。</p>
<p>下面的 <code>Update</code>，设置了每一帧会变的参数，Dispatch 之后，再通过 <code>GetData</code> 阻塞等待 Compute Shader kernel 的计算结果，最后对每一个 Boid 结构赋值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FlockingGPU.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlockingGPU</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;   <span class="comment">// 设置每一帧会变的变量</span></span><br><span class="line">        shader.SetFloat(<span class="string">&quot;deltaTime&quot;</span>, Time.deltaTime);</span><br><span class="line">        shader.SetVector(<span class="string">&quot;flockPosition&quot;</span>, target.transform.position);</span><br><span class="line">        shader.Dispatch(_kernelHandle, _groupSizeX, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 调用 Compute Shader Kernel 来计算</span></span><br><span class="line">        <span class="comment">// 阻塞等待 Compute Shader 计算结果从 GPU 传回来</span></span><br><span class="line">        _boidsBuffer.GetData(_boidsArray);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _boidsArray.Length; i++)</span><br><span class="line">        &#123;   <span class="comment">// 设置鸟的 position 和 rotation</span></span><br><span class="line">            _boids[i].transform.localPosition = _boidsArray[i].position;</span><br><span class="line">            <span class="keyword">if</span> (!_boidsArray[i].direction.Equals(Vector3.zero))</span><br><span class="line">            &#123;</span><br><span class="line">                _boids[i].transform.rotation = Quaternion.LookRotation(_boidsArray[i].direction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Compute Shader 中，也要定义一个 Boid 结构和相对应的 <code>RWStructuredBuffer&lt;Boid&gt;</code> 来用脚本传来的 Compute Buffer。Shader 主要就是对一只鸟遍历一定范围内的鸟群的信息，计算出结果返回给脚本。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleFlocking.compute</span></span><br><span class="line"><span class="meta">#pragma kernel CSMain</span></span><br><span class="line"><span class="meta">#define GROUP_SIZE 256</span></span><br><span class="line"></span><br><span class="line">struct Boid</span><br><span class="line">&#123;   <span class="comment">// Compute Shader 也定义好相关的结构</span></span><br><span class="line">    float3 position;</span><br><span class="line">    float3 direction;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RWStructuredBuffer&lt;Boid&gt; boidsBuffer; <span class="comment">// 允许读写的数据 buffer</span></span><br><span class="line"><span class="type">float</span> deltaTime;</span><br><span class="line">float3 flockPosition;</span><br><span class="line"></span><br><span class="line">[numthreads(GROUP_SIZE,<span class="number">1</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="type">void</span> CSMain(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    Boid boid = boidsBuffer[id.x];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; boidsCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == id.x)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Boid tempBoid = boidsBuffer[i];</span><br><span class="line">        <span class="comment">// 通过周围的鸟的信息，计算经过三个特性后，这一只鸟的方向和位置。</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    boid.direction = lerp(direction, <span class="built_in">normalize</span>(boid.direction), <span class="number">0.94</span>);</span><br><span class="line">    boid.position += boid.direction * boidSpeed * deltaTime;</span><br><span class="line">    <span class="comment">// 设置数据到 Buffer，等待 CPU 读取</span></span><br><span class="line">    boidsBuffer[id.x] = boid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Dispatch</code> 之后 <code>GetData</code> 是阻塞的，如果想异步地获取数据，Unity 2019 新引入一个 API：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Rendering.AsyncGPUReadbackRequest.html">AsyncGPUReadbackRequest</a> ，可以让我们先发送一个获取数据的请求，再每一帧去查询数据是否计算完。也有同学用了测出第一次调用耗时较多等问题，具体可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/h5502637/article/details/85637872">Compute Shader 功能测试（二）</a>。</p>
<p>下面是 100 只鸟的结果：</p>
<p><img src="http://img.frankorz.com/boids-run-demo.gif" alt="100只鸟的结果"></p>
<p>通过 Compute Shader，我们可以通过 Compute Shader 在 GPU 直接计算好需要计算的东西（例如位置、mesh 顶点等），并与传统着色器共享一个 <code>ComputeBuffer</code> ，直接在 GPU 渲染，这样就省去渲染时 CPU 再次传数据给 GPU 的耗时。我们也可以将 Compute Shader 计算后的数据返回给 CPU 再做额外的计算。总而言之，Compute Shader 十分灵活。</p>
<h3 id="CPU-端计算-vs-GPU-端计算">CPU 端计算 vs GPU 端计算</h3>
<p>假设我们在 CPU 端不用任何 DOTS，直接在每个 Update 中 for 每个鸟计算朝向和位置，这样性能是非常差的。</p>
<p>下图是把计算都放到 C# Update 中的 Profile：</p>
<p><img src="http://img.frankorz.com/boid-profile-1.png" alt="C# 每个 Update 中直接计算"></p>
<p>如果放到 Compute Shader 计算，每个 Update 更新数据，这样 CPU 消耗小了很多。</p>
<p><img src="http://img.frankorz.com/boid-profile-2.png" alt="Compute Shader 计算，每个 Update 更新数据"></p>
<p>感兴趣的朋友可以对比下 FlockingCPU.cs 和 FlockingGPU.cs 的代码，会发现两者的代码其实十分相似，只不过前者把 for loop 放到脚本，后者放到了 Compute Shader 中而已，因此如果大家觉得有一些地方十分适合并行计算，就可以考虑把这部分计算放到 GPU 计算。</p>
<h3 id="Profile-Compute-Shader">Profile Compute Shader</h3>
<p>我们可以通过 Profiler 来看 GPU 利用情况，通常这个面板是隐藏的，需要手动打开。</p>
<p>也可以通过 RenderDoc 来看，这里不展示。</p>
<p><img src="http://img.frankorz.com/boid-profile-3.png" alt="boid-profile-3"></p>
<h3 id="优化：DrawMeshInstanced">优化：DrawMeshInstanced</h3>
<p>前面我们用 <code>Instantiate</code> 来初始化鸟群，其实我们也能通过 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/GPUInstancing.html">GPU instancing</a> 来优化，用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Graphics.DrawMeshInstanced.html">Graphics.DrawMeshInstanced</a> 来实例化 prefab。这个优化未包含在 Github 例子中，这里提供思路。</p>
<p><img src="http://img.frankorz.com/boid-profile-4.png" alt="boid-profile-4"></p>
<p>这么做的话，位置和旋转都要在传统 shader 中计算成变换矩阵应用在顶点上，因此为了防止 Compute Shader 数据传回 CPU 再传到 GPU 的传统 shader 的开销，需要两个 Shader 共享一个 <code>StructuredBuffer</code> 。</p>
<p>这样如果要给模型加动画的话，还得提前烘焙动画，将每一帧动画的顶点和当前帧数提前传到 vertex shader(or surface shader) 里做插值，这样做的话还能根据鸟的速度去控制动画的速率。</p>
<h2 id="应用">应用</h2>
<ul>
<li>遮挡剔除（<em>Occlusion Culling</em>）</li>
<li>环境光遮蔽（<em>Ambient Occlusion</em>）
<ul>
<li><a target="_blank" rel="noopener" href="https://www.anandtech.com/show/2848/2">AMD’s Radeon HD 5850: The Other Shoe Drops</a></li>
</ul>
</li>
<li>程序化生成：
<ul>
<li>terrain heightmap evaluation with noise, erosion, and voxel algorithms</li>
</ul>
</li>
<li>AI 寻路
<ul>
<li>Compute Shader 做寻路有点不太好的就是往往游戏（CPU）需要知道计算结果，因此还要考虑 GPU 返回结果给 CPU 的延时。可以考虑做 CPU 端并行的方案，例如用 Job System。</li>
</ul>
</li>
<li>GPU 光线追踪
<ul>
<li><a target="_blank" rel="noopener" href="http://blog.three-eyed-games.com/2018/05/03/gpu-ray-tracing-in-unity-part-1/">GPU Ray Tracing in Unity – Part 1</a></li>
</ul>
</li>
<li>图像处理，例如模糊化等。</li>
<li>其他你想放到 GPU，但是传统着色器干不了的并行的解决方案。</li>
</ul>
<h3 id="原神">原神</h3>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Za4y1s7VL">Unity线上技术大会-游戏专场｜从手机走向主机 -《原神》主机版渲染技术分享</a></p>
<p><img src="http://img.frankorz.com/genshin-render-compute-shader-1.png" alt="Genshin 主机渲染管线简介"></p>
<h4 id="解压预烘焙的-Shadow-Texture">解压预烘焙的 Shadow Texture</h4>
<p>在离线制作的时候，对于烘焙好的 shadow texture 做一个压缩，尽量地去保持精度，运行的时候解压的速度也非常快，用 Compute Shader 去解压的情况，1K×1K 的 shadow texture，解压只需要 0.05 毫秒。</p>
<p><img src="http://img.frankorz.com/genshin-render-compute-shader-2.png" alt="解压预烘焙的 Shadow Texture"></p>
<h4 id="做模糊处理">做模糊处理</h4>
<p>在进行模糊处理的时候，每个像素需要采取周边多个像素的数值进行混合，可以看到，如果使用传统的 PS，每个像素都会需要多次贴图采样，且这些采样结果实际上是可以在相邻其他像素的计算中进行重用的，因此为了进一步提升计算性能，《原神》这里的做法是将模糊处理放到 Compute Shader 中来完成。</p>
<p>具体的做法是，将相邻像素的采样结果存储在 <strong>局部存储空间（Local Data Share）</strong> 中，之后再模糊的时候取用，一次性完成四个像素的模糊计算，并将结果输出。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<h3 id="天涯明月刀">天涯明月刀</h3>
<p><a target="_blank" rel="noopener" href="http://youxiputao.com/articles/21061">《天涯明月刀》手游引擎技术负责人：如何应用GPU Driven优化渲染效果？| TGDC 2020</a></p>
<p><img src="http://img.frankorz.com/gpu-driven-compute-1.png" alt="gpu-driven-compute-1"></p>
<p>做遮挡剔除（Occlusion Culling）时，CPU 只能做到 Object Level，而 GPU 可以通过切分 Mesh 做进一步的剔除。</p>
<p><img src="http://img.frankorz.com/gpu-driven-compute-2.png" alt="gpu-driven-compute-2"></p>
<p>知乎上也有人尝试了实现：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352850047">Unity实现GPUDriven地形</a>。</p>
<h3 id="斗罗大陆">斗罗大陆</h3>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y0QZ3aaJg8S7u1c5sCaZgg">三七研发，这款被称作 “目前最原汁原味的”《斗罗大陆》3D 手游都用到了哪些 Unity 技术？</a></p>
<p>利用 Compute Shader 对所有美术贴图逐像素对比，筛选出大量的重复、相似、屯余、大透明的贴图。</p>
<h3 id="Clay-Book">Clay Book</h3>
<p>基于3D SDF 体渲染的黏土游戏：<a target="_blank" rel="noopener" href="https://www.claybookgame.com/">Claybook Game</a>。</p>
<p>演讲：<a target="_blank" rel="noopener" href="https://youtu.be/Xpf7Ua3UqOA?t=405">DD2018: Sebastian Aaltonen - GPU based clay simulation and ray tracing tech in Claybook</a></p>
<p>动图：<a target="_blank" rel="noopener" href="https://gfycat.com/gaseousterriblechupacabra">https://gfycat.com/gaseousterriblechupacabra</a></p>
<h3 id="Jelly-in-the-sky">Jelly in the sky</h3>
<p><a target="_blank" rel="noopener" href="https://www.reddit.com/r/Unity3D/comments/7j4hay/finished_my_compute_shader_based_game/">Finished my compute shader based game</a> 这帖子的哥们写了六千多行 HLSL 代码做了一个完全在 GPU 执行的基于物理模拟的游戏。</p>
<p>Steam：<a target="_blank" rel="noopener" href="https://store.steampowered.com/app/593530/Jelly_in_the_sky/">Jelly in the sky on Steam</a></p>
<p>动图：<a target="_blank" rel="noopener" href="https://gfycat.com/validsolidcanine">https://gfycat.com/validsolidcanine</a></p>
<h3 id="开源项目">开源项目</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/cinight/MinimalCompute">cinight/MinimalCompute</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/krylov-na/Compute-shader-particles">krylov-na/Compute-shader-particles</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/keijiro/Swarm">keijiro/Swarm</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ellioman/Indirect-Rendering-With-Compute-Shaders">ellioman/Indirect-Rendering-With-Compute-Shaders</a></li>
</ul>
<h2 id="缺点-3">缺点</h2>
<p>虽然 Unity 帮我们做了跨平台的工作，但是我们仍然需要面对一些平台差异。</p>
<p>本小节内容大部分来自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53785954">Compute Shader : Optimize your game using compute</a>。</p>
<ul>
<li>难 Debug</li>
<li><strong>数组越界</strong>，DX 上会返回 0，其它平台会出错。</li>
<li>变量名与关键字/内置库函数<strong>重名</strong>，DX 无影响，其他平台会出错。</li>
<li>如果 SBuffer 内结构的显存布局与<strong>内存布局不一致</strong>，DX 可能会转换，其他平台会出错。</li>
<li><strong>未初始化</strong>的 SBuffer 或 Texture，在某些平台上会全部是 0，但是另外一些可能是任意值，甚至是NaN。</li>
<li>Metal 不支持<strong>对纹理的原子操作</strong>，不支持对 SBuffer 调用 <code>GetDimensions</code>。</li>
<li>ES 3.1 在一个 CS 里<strong>至少支持 4 个 SBuffer</strong>（所以，我们需要将相关联的数据定义为 struct）。</li>
<li>ES 从 3.1 开始支持 CS，也就是说，在手机上的支持率并不是很高。部分号称支持 es 3.1+ 的 Android 手机只支持在片元着色器内访问 StructuredBuffer。
<ul>
<li>使用 <code>SystemInfo.supportsComputeShaders</code> 来判断支不支持<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></li>
</ul>
</li>
</ul>
<h2 id="最后-7">最后</h2>
<p>我相信 Compute Shader 这个词不少读者应该都会在其他地方见过，但是大都觉得这个技术离我们还很远。我身边的朋友问了问也没怎么了解过，更不要说在项目上用了，这也是这篇文章诞生的原因之一。</p>
<p>当我们面临使用 DOTS 还是 Compute Shader 的抉择时，更应该从项目本身出发，考虑计算应该放在 CPU 还是 GPU，Compute Shader 中跟 GPU 沟通的开销是否能够接受。读者也可以参考下 Unity Forum 中相关的讨论：<a target="_blank" rel="noopener" href="https://forum.unity.com/threads/unity-dots-vs-compute-shader.1093228/">Unity DOTS vs Compute Shader</a>。</p>
<p>开始碎碎念，去年的年终总结也没写，今年到现在就憋出一篇文章，十分不应该。其实也是自己没什么好分享的，自己还需要多学习。当然也很高兴通过博客认识到不同朋友，这是我写作的动力，谢谢你们。</p>
<h2 id="参考-2">参考</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/chenjd/Unity-Boids-Behavior-on-GPGPU">chenjd/Unity-Boids-Behavior-on-GPGPU</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74418914">关于Compute Shader的一些基础知识记录</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=0DLOJPSxJEg&amp;t=167s">Compute Shaders: Optimize your engine using compute / Lou Kramer, AMD</a></li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/30426701/">《DirectX 12 3D 游戏开发实战》第13章 计算着色器</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hexiaolong2009/article/details/104088308">Render Hell —— 史上最通俗易懂的GPU入门教程（二）</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/445590537/answer/1742513246#comment-1265841070">知乎 - “问个CUDA并行上的小白问题，既然SM只能同时处理一个WARP，那是不是有的SP处于闲置？”的评论</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="http://youxiputao.com/articles/20948">米哈游技术总监分享：《原神》主机版渲染技术要点和解决方案</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/68886986">ComputeShader 手机兼容性报告</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">猫冬</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://frankorz.com/2021/04/17/compute-shader/">http://frankorz.com/2021/04/17/compute-shader/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://frankorz.com" target="_blank">萤火之森</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/Shader/">Shader</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-57e27fcf6e91c81d" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgswechat-reward.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgswechat-reward.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsalipay-reward.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsalipay-reward.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/18/learn-pixel-art/"><img class="prev-cover" src="http://img.frankorz.com/day23-dog-in-snow.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">24 天像素画从入门到放弃</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/03/add-note-section-to-blog/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsadd-note-section-to-blog-cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">博客新增公开笔记部分</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/04/13/2020-04-tech-reading/" title="2020年4月技术导读"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-13</div><div class="title">2020年4月技术导读</div></div></a></div><div><a href="/2020/05/23/2020-05-tech-reading/" title="2020年5月技术导读"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-23</div><div class="title">2020年5月技术导读</div></div></a></div><div><a href="/2020/10/03/add-note-section-to-blog/" title="博客新增公开笔记部分"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsadd-note-section-to-blog-cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-03</div><div class="title">博客新增公开笔记部分</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgshead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">猫冬</div><div class="author-info__description">各种知识火种~</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Latias94"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Latias94" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:superfrankie621@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://weibo.com/u/1825527674" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到萤火之森🐈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-Compute-Shader"><span class="toc-number">2.</span> <span class="toc-text">最简单的 Compute Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E5%B7%A5%E4%BD%9C%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">如何划分工作：线程与线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E6%9E%84%E6%88%90%E7%9A%84-3D-%E7%BD%91%E6%A0%BC"><span class="toc-number">3.1.</span> <span class="toc-text">线程组构成的 3D 网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84-GPU-%E4%B9%8B%E6%97%85"><span class="toc-number">3.2.</span> <span class="toc-text">线程组的 GPU 之旅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%BA%BF%E7%A8%8B%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.3.</span> <span class="toc-text">如何设置好线程组的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPU-Compute-Unit"><span class="toc-number">4.</span> <span class="toc-text">GPU Compute Unit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BA%A4%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">线程间交流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E9%97%B4%E7%9A%84%E4%BA%A4%E6%B5%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">多个线程组间的交流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%86%85%E7%9A%84%E4%BA%A4%E6%B5%81"><span class="toc-number">4.1.2.</span> <span class="toc-text">单个线程组内的交流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-Register-%E5%92%8C-Scalar-Register"><span class="toc-number">4.2.</span> <span class="toc-text">Vector Register 和 Scalar Register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%9D%80%E8%89%B2%E5%99%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">4.3.</span> <span class="toc-text">与传统着色器执行流程的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vert-Frag-Shader"><span class="toc-number">4.3.1.</span> <span class="toc-text">Vert-Frag Shader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Compute-Shader"><span class="toc-number">4.3.2.</span> <span class="toc-text">Compute Shader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-number">4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boids-%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">Boids 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.</span> <span class="toc-text">设置数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.</span> <span class="toc-text">获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E7%AB%AF%E8%AE%A1%E7%AE%97-vs-GPU-%E7%AB%AF%E8%AE%A1%E7%AE%97"><span class="toc-number">5.3.</span> <span class="toc-text">CPU 端计算 vs GPU 端计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile-Compute-Shader"><span class="toc-number">5.4.</span> <span class="toc-text">Profile Compute Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%EF%BC%9ADrawMeshInstanced"><span class="toc-number">5.5.</span> <span class="toc-text">优化：DrawMeshInstanced</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%A5%9E"><span class="toc-number">6.1.</span> <span class="toc-text">原神</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E9%A2%84%E7%83%98%E7%84%99%E7%9A%84-Shadow-Texture"><span class="toc-number">6.1.1.</span> <span class="toc-text">解压预烘焙的 Shadow Texture</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9A%E6%A8%A1%E7%B3%8A%E5%A4%84%E7%90%86"><span class="toc-number">6.1.2.</span> <span class="toc-text">做模糊处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E6%B6%AF%E6%98%8E%E6%9C%88%E5%88%80"><span class="toc-number">6.2.</span> <span class="toc-text">天涯明月刀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86"><span class="toc-number">6.3.</span> <span class="toc-text">斗罗大陆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clay-Book"><span class="toc-number">6.4.</span> <span class="toc-text">Clay Book</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jelly-in-the-sky"><span class="toc-number">6.5.</span> <span class="toc-text">Jelly in the sky</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-number">6.6.</span> <span class="toc-text">开源项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">7.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E-7"><span class="toc-number">8.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83-2"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/rust-study-resource/" title="Rust 学习资源"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsrust-study-resource-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust 学习资源"/></a><div class="content"><a class="title" href="/2022/01/18/rust-study-resource/" title="Rust 学习资源">Rust 学习资源</a><time datetime="2022-01-18T14:01:44.000Z" title="发表于 2022-01-18 14:01:44">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/05/rust-raytrace/" title="用 Rust 实现简单的光线追踪"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsrust-raytrace-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用 Rust 实现简单的光线追踪"/></a><div class="content"><a class="title" href="/2021/05/05/rust-raytrace/" title="用 Rust 实现简单的光线追踪">用 Rust 实现简单的光线追踪</a><time datetime="2021-05-05T00:48:30.000Z" title="发表于 2021-05-05 00:48:30">2021-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/18/learn-pixel-art/" title="24 天像素画从入门到放弃"><img src="http://img.frankorz.com/day23-dog-in-snow.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24 天像素画从入门到放弃"/></a><div class="content"><a class="title" href="/2021/04/18/learn-pixel-art/" title="24 天像素画从入门到放弃">24 天像素画从入门到放弃</a><time datetime="2021-04-18T12:33:30.000Z" title="发表于 2021-04-18 12:33:30">2021-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/17/compute-shader/" title="Compute Shader 简介"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgscompute-shader-cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Compute Shader 简介"/></a><div class="content"><a class="title" href="/2021/04/17/compute-shader/" title="Compute Shader 简介">Compute Shader 简介</a><time datetime="2021-04-17T22:14:30.000Z" title="发表于 2021-04-17 22:14:30">2021-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/03/add-note-section-to-blog/" title="博客新增公开笔记部分"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsadd-note-section-to-blog-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客新增公开笔记部分"/></a><div class="content"><a class="title" href="/2020/10/03/add-note-section-to-blog/" title="博客新增公开笔记部分">博客新增公开笔记部分</a><time datetime="2020-10-03T15:53:30.000Z" title="发表于 2020-10-03 15:53:30">2020-10-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 猫冬</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="beian.miit.gov.cn"><span>粤ICP备19098175号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://frankorz.com/2021/04/17/compute-shader/'
    this.page.identifier = '2021/04/17/compute-shader/'
    this.page.title = 'Compute Shader 简介'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://frankorz.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>