<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>洞明 Unity ECS 基础概念 | 萤火之森</title><meta name="keywords" content="游戏开发,ECS"><meta name="author" content="猫冬"><meta name="copyright" content="猫冬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虽然网络上已经有不少 ECS 文档的汉化，但自己读官方文档的时候也会产生不少疑问，为此通过查询各种资料，写下本文。 本文从 ECS 官方文档出发，加之内存布局结构的讲解，力求读者能够和博主一起吃透 ECS 中的基本概念。同时建议读者可以先读读我的上一篇博文《Unity DOTS 走马观花》的 ECS 部分，本文不再复述前文已经提到过的相关概念。 ECS 与 Job System 我认为有必要重申其">
<meta property="og:type" content="article">
<meta property="og:title" content="洞明 Unity ECS 基础概念">
<meta property="og:url" content="http://frankorz.com/2019/07/14/clarify-ecs-basic-concept/index.html">
<meta property="og:site_name" content="萤火之森">
<meta property="og:description" content="虽然网络上已经有不少 ECS 文档的汉化，但自己读官方文档的时候也会产生不少疑问，为此通过查询各种资料，写下本文。 本文从 ECS 官方文档出发，加之内存布局结构的讲解，力求读者能够和博主一起吃透 ECS 中的基本概念。同时建议读者可以先读读我的上一篇博文《Unity DOTS 走马观花》的 ECS 部分，本文不再复述前文已经提到过的相关概念。 ECS 与 Job System 我认为有必要重申其">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg">
<meta property="article:published_time" content="2019-07-14T20:13:00.000Z">
<meta property="article:modified_time" content="2022-03-07T02:16:08.253Z">
<meta property="article:author" content="猫冬">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="ECS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsfavicon.png"><link rel="canonical" href="http://frankorz.com/2019/07/14/clarify-ecs-basic-concept/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?91a6af339098c7b3314fd48d6640bbf8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-69634396-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-69634396-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '洞明 Unity ECS 基础概念',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-07 02:16:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="萤火之森" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgshead.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.notion.so/frankorz/e9a64743c07743f08605f5df7cb57eaf"><i class="fa-fw far fa-sticky-note"></i><span> 公开笔记</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/pixel-art/"><i class="fa-fw fas fa-palette"></i><span> 像素画</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">萤火之森</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.notion.so/frankorz/e9a64743c07743f08605f5df7cb57eaf"><i class="fa-fw far fa-sticky-note"></i><span> 公开笔记</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></div><div class="menus_item"><a class="site-page" href="/pixel-art/"><i class="fa-fw fas fa-palette"></i><span> 像素画</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">洞明 Unity ECS 基础概念</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-07-14T20:13:00.000Z" title="发表于 2019-07-14 20:13:00">2019-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-07T02:16:08.253Z" title="更新于 2022-03-07 02:16:08">2022-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="洞明 Unity ECS 基础概念"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>虽然网络上已经有不少 ECS 文档的汉化，但自己读官方文档的时候也会产生不少疑问，为此通过查询各种资料，写下本文。</p>
<p>本文从 ECS 官方文档出发，加之内存布局结构的讲解，力求读者能够和博主一起吃透 ECS 中的基本概念。同时建议读者可以先读读我的上一篇博文<a href="http://frankorz.com/2019/05/07/simple-talk-unity-dots/#Entity-Component-System">《Unity DOTS 走马观花》</a>的 ECS 部分，本文不再复述前文已经提到过的相关概念。</p>
<h1>ECS 与 Job System</h1>
<p>我认为有必要重申其两者的关系。</p>
<ul>
<li>Job System 能帮我们方便地写出线程安全的多线程代码，其中每个任务单元称为 Job。</li>
<li>ECS，又称实体组件系统。与传统的面向对象编程相比，ECS 是一种基于数据设计的编程模式。<a href="http://frankorz.com/2019/05/07/simple-talk-unity-dots/#Entity-Component-System">前文</a>从内存结构分析了 OOP 模式的缺点，也提到了 ECS 是怎么样基于数据的设计内存结构的。</li>
</ul>
<p>Job System 是 Unity 自带的库，而要使用 ECS 我们需要从 Package Manager 中安装 “Entities” 预览包。这两者虽说完全是两种东西，但是他们能很好地相辅相成：ECS 保证数据线性地排列在内存中，这样通过更高效的数据读取，能有效提升 Job 的执行速度，同时也给了 Burst 编译器更多优化的机会。</p>
<span id="more"></span>
<h1>Entities（实体）</h1>
<p>在 <code>World</code>中， <code>EntityManager</code> 管理所有实体和组件。</p>
<p>当你需要创建实体和为其添加组件的时候， <code>EntityManager</code>会一直跟踪所有独立的组件组合（也就是原型 Archetype）。</p>
<h2 id="创建实体">创建实体</h2>
<p>最简单的方法就是在编辑器直接挂一个 <code>ConvertToEntity</code> 脚本，在运行时中把 GameObject 转成实体。</p>
<p><img src="http://img.frankorz.com/5d2afb77ee64e53003.png" alt="在编辑器中挂脚本，GameObject 会在运行时中转成实体"></p>
<p>在编辑器中挂脚本，GameObject 会在运行时中转成实体</p>
<p>脚本中，你也可以创建系统（System）并在一个 Job 中创建多个实体，也可以通过 <code>EntityManager.CreateEntity</code> 方法来一次生成大量 Entity。</p>
<p>我们可以通过下面四种方法来创建一个实体：</p>
<ul>
<li>用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.ComponentType.html">ComponentType</a> 数组创建一个带组件的实体</li>
<li>用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityArchetype.html">EntityArchetype</a> 创建一个带组件的实体</li>
<li>用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_">Instantiate</a> 复制一个已存在的实体和其当前的数据，</li>
<li>创建一个空的实体然后再为其添加组件</li>
</ul>
<p>也可以通过下面的方法一次性创建多个实体：</p>
<ul>
<li>用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateEntity">CreateEntity</a> 来创建相同原型（archetype）的实体并填满一个 NativeArray （要多少实体就提前设定好 NativeArray 的长度）</li>
<li>用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_Instantiate_Unity_Entities_Entity_">Instantiate</a> 来复制一个已存在的实体并填满一个 NativeArray</li>
<li>用 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_CreateChunk_">CreateChunk</a> 来显式创建内存块（Chunks），并且填入自定数量的给定原型的实体</li>
</ul>
<h2 id="增加和移除组件">增加和移除组件</h2>
<p>实体被创建之后，我们可以增加和移除其组件。当我们这样做的时候，相关联的原型（Archetype）将会被改变， <code>EntityManager</code> 也需要改变内存布局，将受影响的数据移到新的内存块（new Chunk of memory），同时也会压缩原来内存块中的组件数组。</p>
<p>对实体的修改会带来内存结构的改变。</p>
<p>实体的修改包括：</p>
<ul>
<li>增加和移除组件</li>
<li>改变 <code>SharedComponentData</code>的值</li>
<li>增加和删除实体</li>
</ul>
<p>这些操作都不能放到 Job 中执行，因为这些都会改变内存中的数据结构。因此我们需要用到命令（Commands）来保存这些操作，将这些操作存到 <code>EntityCommandBuffer</code> 中，然后在 Job 完成后再依次执行 <code>EntityCommandBuffer</code> 中储存的操作。</p>
<h1>World（世界）</h1>
<p>每一个 <code>World</code> 包含一个 <code>EntityManager</code> 和一系列的 <code>ComponentSystem</code>。一个世界中的实体、原型、系统等都不能被另外一个世界访问到。你可以创建很多 <code>World</code> ，例如通常我们会使用或创建一个负责主要逻辑运算的 simulation <code>World</code> 和负责图形渲染的 rendering <code>World</code> 或 presentation <code>World</code>。</p>
<p>当我们点击运行按钮进入 <strong>Play Mode</strong> 时，Unity 会默认创建一个 <code>World</code>，并且增加项目中所有可用的 <code>ComponentSystem</code>。我们也可以关闭默认的 <code>World</code> 从而自己创建一个。</p>
<ul>
<li><strong>Default World creation code</strong> (see file: <em>Packages/com.unity.entities/Unity.Entities.Hybrid/Injection/DefaultWorldInitialization.cs</em>)</li>
<li><strong>Automatic bootstrap entry point</strong> (see file:<em>Packages/com.unity.entities/Unity.Entities.Hybrid/Injection/AutomaticWorldBootstrap.cs</em>)</li>
</ul>
<h1>Components（组件）</h1>
<p>ECS 中的组件是一种结构，可以通过实现下列接口来实现：</p>
<ul>
<li>IComponentData</li>
<li>ISharedComponentData</li>
<li>ISystemStateComponentData</li>
<li>ISharedSystemStateComponentData</li>
</ul>
<p><code>EntityManager</code> 会组织所有实体中独立的的组件组合成不同的<strong>原型（Archetypes）</strong>，还会将拥有同样原型的所有实体的组件（数据）储存到一起，都放到同一个**内存块（Chunks）**中。</p>
<p>如果你为一个实体新增了一个组件，那么其原型就改变了，实体的数据也需要从原来的内存块移到新的内存块，因为只有相同原型的实体数据才会放到相同的内存块中。</p>
<p>一个原型由很多个内存块组成，这些内存块中存的都是拥有相同原型的实体。</p>
<p><img src="http://img.frankorz.com/5cd16af8d2324.png" alt=""></p>
<h2 id="General-Purpose-Component（普通用途组件）">General Purpose Component（普通用途组件）</h2>
<p>这里指的是最普通的组件，可以通过实现 <code>IComponentData</code> 接口来创建。</p>
<p><code>IComponentData</code> 不存储行为，只储存数据。<code>IComponentData</code> 还是一个结构体（Struct）而不是一个类（Class），这意味着被复制时默认是通过值而不是通过引用。</p>
<p>通常我们会用下面的<strong>模式</strong>来修改组件数据：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transform = <span class="keyword">group</span>.transform[index]; <span class="comment">// Read</span></span><br><span class="line">    </span><br><span class="line">transform.heading = playerInput.move; <span class="comment">// Modify</span></span><br><span class="line">transform.position += deltaTime * playerInput.move * settings.playerMoveSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span>.transform[index] = transform; <span class="comment">// Write</span></span><br></pre></td></tr></table></figure>
<p><code>IComponentData</code> 结构不包含托管对象（managed objects）的引用，所有<code>IComponentData</code> 被存在无垃圾回收的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html">块内存（chunk memory）</a>中。</p>
<p>你可能还听过一种组件是不包含数据、只用来标记的“Tag”组件（Tag component），其用途也很广，例如我们可以轻易地给实体加标记来区分玩家和敌人，这样系统中能更容易通过组件的类型来筛选我们想要的实体。如果我们给一个内存块（Chunk）中的所有实体都添加&quot;Tag“组件的话，只有内存块中对应的原型会修改，不添加数据，因此官方也推荐利用好”Tag“组件。</p>
<p>See file: /Packages/com.unity.entities/Unity.Entities/IComponentData.cs.</p>
<h2 id="Shared-components（共享组件）">Shared components（共享组件）</h2>
<p>Shared components 是一种特殊的组件，你可以把某些特殊的需要共享的值放到 shared component 中，从而在实体中与其他组件划分开。例如有时候我们的实体需要共享一套材质，我们可以为需要共享的材质创建 <code>Rendering.RenderMesh</code>，再放到 shared components 中。原型中也可以定义 shared components，这一点和其他组件是一样的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> RenderMesh : ISharedComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Mesh                 mesh;</span><br><span class="line">    <span class="keyword">public</span> Material             material;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ShadowCastingMode    castShadows;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>                 receiveShadows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你为一个实体添加一个 shared components 时， <code>EntityManager</code> 会把所有带有同样 shared components 的实体放到一个同样的内存块中（Chunks）。shared components 允许我们的系统去一并处理相似的（有同样 shared components 的）实体。</p>
<h3 id="内存结构">内存结构</h3>
<p><img src="http://img.frankorz.com/5d295d398f62598876.png" alt=""></p>
<p>每个内存块（Chunk）会有一个存放 shared components 索引的数组。这句话包含了几个要点：</p>
<ol>
<li>对于实体来说，有同样 <code>SharedComponentData</code> 的实体会被一起放到同样的内存块（Chunk）中。</li>
<li>如果我们有两个存储在同样的内存块中的两个实体，它们有同样的 <code>SharedComponentData</code> 类型和值。我们修改其中一个实体的 <code>SharedComponentData</code> 的值，这样会导致这个实体会被移动到一个新的内存块中，因为一个内存块共享同一个数组的 <code>SharedComponentData</code> 索引。事实上，从一个实体中增加或者移除一个组件，或者改变 shared components 的值都会导致这种操作的发生。</li>
<li>其索引存储在内存块而非实体中，因此 <code>SharedComponentData</code> 对实体来说是低开销的。</li>
<li>因为内存块只需要存其索引，<code>SharedComponentData</code> 的内存消耗几乎可以忽略不计。</li>
</ol>
<p>因为上面的第二个要点，我们不能滥用 shared components。滥用 shared components 将让 Unity 不能利用好内存块（Chunk），因此我们要避免添加不必要的数据或修改数据到 shared components 中。我们可以通过 Entity Debugger 来监测内存块的利用。</p>
<p><img src="http://img.frankorz.com/5d295b6d78b7f51832.png" alt=""></p>
<p>拿上一段 RenderMesh 的例子来说，共享材质会更有效率，因为 shared components 有其自己的 <code>manager</code> 和哈希表。其中 <code>manager</code> 带有一个存储 shared components 数据的自由列表（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%A1%A8">freelist</a>），哈希表可以快速地找到相应的值。内存块里面存的是索引数组，需要找数据的时候就会从 Shared Component Manager 中找。</p>
<h3 id="其他要点">其他要点</h3>
<ul>
<li><code>EntityQuery</code> 可以迭代所有拥有相同 <code>SharedComponentData</code> 的实体</li>
<li>我们可以用 <code>EntityQuery.SetFilter()</code> 来迭代所有拥有某个特定 <code>SharedComponentData</code> 的实体。这种操作开销十分低，因为 <code>SetFilter</code> 内部筛选的只是 int 的索引。前面说了每个内存块都有一个<code>SharedComponentData</code> 索引数组，因此对于每个内存块来说，筛选（filtering）的消耗都是可以忽略不计的。</li>
<li>怎么样获取 <code>SharedComponentData</code> 的值呢？<code>EntityManager.GetAllUniqueSharedComponentData&lt;T&gt;</code> 可以得到在存活的实体中（alive entities）的所有的泛型 T 类型的<code>SharedComponentData</code> 值，结果以参数中的列表返回，你也可以通过其重载的方法获得所有值的索引。其他获取值的方法可以参考 /Packages/com.unity.entities/Unity.Entities/EntityManagerAccessComponentData.cs。</li>
<li><code>SharedComponentData</code> 是自动引用计数的，例如在没有任何内存块拥有某个<code>SharedComponentData</code> 索引的时候，引用计数会置零，从而知道要删除<code>SharedComponentData</code> 的数据 。这一点就能看出其在 ECS 的世界中是非常独特的存在，想要深入了解可以看这篇文章<a target="_blank" rel="noopener" href="https://gametorrahod.com/everything-about-isharedcomponentdata/">《Everything about ISharedComponentData》</a>。</li>
<li><code>SharedComponentData</code> 应该尽量不去更改，因为更改 <code>SharedComponentData</code> 会导致实体的组件数据需要复制到其他的内存块中。</li>
</ul>
<p>你也可以读读这篇更深入的文章<a target="_blank" rel="noopener" href="https://gametorrahod.com/everything-about-isharedcomponentdata/">《Everything about ISharedComponentData》</a>。</p>
<h2 id="System-state-components（系统状态组件）">System state components（系统状态组件）</h2>
<p><code>SystemStateComponentData</code> 允许你跟踪系统（System）的资源，并允许你合适地创建和删除某些资源，这些过程中不依赖独立的回调（individual callback）。</p>
<blockquote>
<p>假设有一个网络同步 System State，其监控一个 Component A 的同步，则我只需要定义一个 SystemStateComponent SA。当 Entity [有 A，无 SA] 时，表示 A 刚添加，此时添加 SA。等到 Entity [无 A，有 SA] 时,表示 A 被删除（尝试销毁Entity 时也会删除 A）。<br>
<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/51289405">《浅入浅出Unity ECS》</a> BenzzZX</p>
</blockquote>
<p><code>SystemStateComponentData</code>  和 <code>SystemStateSharedComponentData</code> 这两个类型与 <code>ComponentData</code> 和 <code>SharedComponentData</code> 十分相似，不同的是前者两个类型都是系统级别的，不会在实体删除的时候被删除。</p>
<h3 id="Motivation（诱因）">Motivation（诱因）</h3>
<p>System state components 有这样特殊的行为，是因为：</p>
<ul>
<li>系统可能需要保持一个基于 <code>ComponentData</code> 的内部状态。例如已经被分配的资源。</li>
<li>系统需要通过值来管理这些状态，也需要管理其他系统所造成的的状态改变。例如在组件中的值改变的时候，或者在相关组件被添加或者被删除的时候。</li>
<li>“没有回调”是 ECS 设计规则的重要元素。</li>
</ul>
<h3 id="Concept（概念）">Concept（概念）</h3>
<p><code>SystemStateComponentData</code> 普遍用法是镜像一个用户组件，并提供内部状态。</p>
<p>上面引用的网络同步的例子中，A 就是用户分配的 <code>ComponentData</code>，SA 就是系统分配的 <code>SystemComponentData</code>。</p>
<p>下面以 FooComponent （<code>ComponentData</code>）和 FooStateComponent（<code>SystemComponentData</code>）做主要用途的示例。前两个用途已经在前面的网络同步例子中呈现过。</p>
<h4 id="检测组件的添加">检测组件的添加</h4>
<p>如果用户添加 FooComponent 时，FooStateComponent 还不存在。FooSystem 会在 update 中查询，如果实体只有 FooComponent 而没有 FooStateComponent,，则可以判断这个实体是新添加的。这时候 FooSystem 会加上 FooStateComponent 组件和其他需要的内部状态。</p>
<h4 id="检测组件的删除">检测组件的删除</h4>
<p>如果用户删除 FooComponent 后，FooStateComponent 仍然存在。FooSystem 会在 update 中查询，如果实体没有 FooComponent 而有 FooStateComponent,，则可以判断 FooComponent 已经被删除了。这时候 FooSystem 会给删除 FooStateComponent 组件和修改其他需要的内部状态。</p>
<h4 id="监测实体的删除">监测实体的删除</h4>
<p>通常 <code>DestroyEntity</code> 这个方法可以用来：</p>
<ol>
<li>找到所有由某个实体 ID 标记的所有组件</li>
<li>删除那些组件</li>
<li>回收实体 ID 以作重用</li>
</ol>
<p>然而，<code>DestroyEntity</code> 无法删除 <code>SystemStateComponentData</code> 。</p>
<p>在你删除实体时，<code>EntityManager</code> <strong>不会</strong>移除任何 system state components，在它们没被删除的时候，<code>EntityManager</code> 也不会回收其实体的 ID 。这样允许系统（System）在一个实体被删除的时候，去整理内部的状态（internal state），也能清理关联着实体 ID 的相关的资源和状态。实体 ID 只会在所有 <code>SystemStateComponentData</code> 被删除的时候才被重用。</p>
<h2 id="Dynamic-Buffers（动态缓冲）">Dynamic Buffers（动态缓冲）</h2>
<p><code>DynamicBuffer</code> 也是组件的一种类型，它能把一个变量内存空间大小的弹性的缓冲（variable-sized, “stretchy” buffer）和一个实体关联起来。它内部存储着一定数量的元素，但如果内部所占内存空间太大，会额外划分一个堆内存（heap memory）来存储。</p>
<p>动态缓冲的内存管理是全自动的。与 <code>DynamicBuffer</code> 关联的内存由 <code>EntityManager</code> 来管理，这样当<code>DynamicBuffer</code> 组件被删除的时候，所关联的堆内存空间也会自动释放掉。</p>
<p>上面的解释可能略显苍白，实际上 <code>DynamicBuffer</code> 可以看成一个有默认大小的数组，其行为和性能都和 <code>NativeArray</code>（在 ECS 中常用的无 GC 容器类型）差不多，但是存储数据超过默认大小也没关系，上文提到了会创建一个堆内存来存储多的数据。<code>DynamicBuffer</code> 可以通过 <code>ToNativeArray</code> 转成 <code>NativeArray</code> 类型，其中只是把指针重新指向缓冲，不会复制数据。</p>
<p><a target="_blank" rel="noopener" href="http://tsubakit1.hateblo.jp/entry/2018/11/07/234502">【Unity】ECSで配列を格納する Dynamic Buffers</a> 这篇文章中，作者用<code>DynamicBuffer</code> 来储存临近的圆柱体实体，从而更方便地与这些实体交互。</p>
<h3 id="定义缓冲">定义缓冲</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8 指的是缓冲中默认元素的数量，例如这例子中存的是 Integer 类型</span></span><br><span class="line"><span class="comment">// 那么 8 integers （32 bytes）就是缓冲的默认大小</span></span><br><span class="line"><span class="comment">// 64 位机器中则占 16 bytes</span></span><br><span class="line">[<span class="meta">InternalBufferCapacity(8)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyBufferElement : IBufferElementData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 下面的隐式转换是可选的，这样可以少写些代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">MyBufferElement e</span>)</span> &#123; <span class="keyword">return</span> e.Value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">MyBufferElement</span>(<span class="params"><span class="built_in">int</span> e</span>)</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> MyBufferElement &#123; Value = e &#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个缓冲元素要存储的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能有点奇怪，我们要定义缓冲中元素的结构而不是 <code>Buffer</code> 缓冲本身，其实这样在 ECS 中有两个好处：</p>
<ol>
<li>对于 <code>float3</code> 或者其他常见的值类型来说，这样能支持多种 <code>DynamicBuffer</code> 。我们可以重用已有的缓冲元素的结构，来定义其他的 <code>Buffers</code>。</li>
<li>我们可以将 <code>Buffer</code> 的元素类型包含在 <code>EntityArchetypes</code> 中，这样它会表现得像拥有一个组件一样。例如用 <code>AddBuffer()</code> 方法，可以通过 <code>entityManager.AddBuffer&lt;MyBufferElement&gt;(entity);</code> 来添加缓冲。</li>
</ol>
<h1>Systems（系统）</h1>
<p>系统负责将组件数据从一个状态（state）通过逻辑处理到下一个状态。例如系统可以根据帧间隔和实体的速度，在当前帧更新所有移动实体的位置。</p>
<p>世界初始化后提供了三个系统组（system groups），分别是 initialization、simulation 和 presentation，它们会按顺序在每帧中执行。</p>
<p>系统组的概念会在下文提到。</p>
<h2 id="ComponentSystem（组件系统）">ComponentSystem（组件系统）</h2>
<p><code>ComponentSystem</code> 通常指 ECS 实体组件系统中最基本的概念 System，它提供要执行的操作给实体。</p>
<p><code>ComponentSystem</code> 不能包含实体的数据。从传统的开发模式来看，它与旧的 Component 类有点相似，不过 <code>ComponentSystem</code>  <strong>只包含方法</strong>。</p>
<p>一个 <code>ComponentSystem</code>  负责更新所有<strong>匹配组件类型</strong>的实体。例如：系统可以通过条件过滤来获得所有拥有 Player 标记（Tag）和位置（Translation）的实体，再对获得的一系列 Player 实体进行处理。其中这种条件过滤由 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/component_group.html">EntityQuery</a> 结构定义。</p>
<p><img src="http://img.frankorz.com/5d29bcddd863174576.png" alt=""></p>
<p>要注意的是，<code>ComponentSystem</code> 只在<strong>主线程</strong>中执行。</p>
<p>我们可以通过继承 <code>ComponentSystem</code>  抽象类来定义我们的系统。</p>
<p>See file: /Packages/com.unity.entities/Unity.Entities/ComponentSystem.cs.</p>
<h2 id="JobComponentSystem（任务组件系统）">JobComponentSystem（任务组件系统）</h2>
<p>前文提到了 ECS 能很好的和 JobSystem 一起合作，那么这个类型就是一个很好的例子。<code>ComponentSystem</code> 只在<strong>主线程</strong>中执行，而 <code>JobComponentSystem</code>  则能在<strong>多线程</strong>中执行，更能利用多核的优势。</p>
<p><img src="http://img.frankorz.com/5d29bd129f0d058419.png" alt=""></p>
<h3 id="自动化的-Job-依赖管理">自动化的 Job 依赖管理</h3>
<p><code>JobComponentSystem</code> 能帮我们自动管理依赖。原理很简单，来自不同系统的 Job 可以并行地读取相同类型的 <code>IComponentData</code>。如果其中一个 Job 正在写（write）数据，那么所有的 Job 就不能并行地执行，而是设定它们的依赖来安排执行顺序。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedSystem</span> : <span class="title">JobComponentSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="keyword">struct</span> RotationSpeedRotation : IJobForEach&lt;Rotation, RotationSpeed&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> dt;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">ref</span> Rotation rotation, [ReadOnly]<span class="keyword">ref</span> RotationSpeed speed</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            rotation.<span class="keyword">value</span> = math.mul(math.normalize(rotation.<span class="keyword">value</span>), quaternion.axisAngle(math.up(), speed.speed * dt));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有对 Rotation 读/写的和对 RotationSpeed 进行写操作的</span></span><br><span class="line">        <span class="comment">// 已经排程的 Job 会自动放到 JobHandle 类型的依赖句柄 inputDeps 中</span></span><br><span class="line">        <span class="comment">// 在方法中，我们也需要把自己的 Job 依赖加进句柄中，并在方法末尾返回回来。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> JobHandle <span class="title">OnUpdate</span>(<span class="params">JobHandle inputDeps</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> job = <span class="keyword">new</span> RotationSpeedRotation() &#123; dt = Time.deltaTime &#125;;</span><br><span class="line">        <span class="keyword">return</span> job.Schedule(<span class="keyword">this</span>, inputDeps);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="怎么运行的？">怎么运行的？</h3>
<p>所有 Jobs 和系统会声明它们会读/写哪些组件类型（ComponentTypes）。JobComponentSystem 返回的 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">JobHandle</a> 依赖句柄会自动注册到 <code>EntityManager</code> 中，以及所有包含读或写（reading or writing）信息的类型中。</p>
<p>这样如果一个系统对 Component A 进行写操作而之后另一个系统会对其进行读操作， <code>JobComponentSystem</code> 会查询读取（reading）的类型列表，然后传给你一个依赖。依赖包含第一个系统返回的 JobHandle，也就是包含“一个系统对 Component A 进行写操作”这个依赖，并将其作为第二个系统的参数传入。</p>
<p><code>JobComponentSystem</code> 简单地按照需求维护一个依赖链，这样不会对主线程造成影响。但是如果一个非 Job 的 <code>ComponentSystem</code> 要存取（access）相同的数据会怎么样呢？因为所有的存取都是声明好的，因此对于所有 <code>ComponentSystem</code> 需要进行存取的组件类型（component type）相关联的 Jobs，<code>ComponentSystem</code> 都会先自动完成这些相关的 Jobs，再在 <code>OnUpdate</code> 中调用依赖。</p>
<h3 id="依赖管理是保守的（conservative）和确定性的（deterministic）">依赖管理是保守的（conservative）和确定性的（deterministic）</h3>
<p>依赖管理是保守的。 <code>ComponentSystem</code> 只是简单的跟踪所有使用的 <code>EntityQuery</code>，然后基于 <code>EntityQuery</code> 存储需要读或写的类型。</p>
<p>当在一个系统中分发多个 Jobs 的时候，依赖必须被发送到所有 Jobs 中，即使不同的 Jobs 可能需要更少的依赖。如果这里被证明有性能问题，那最好的解决方法是将系统一分为二。</p>
<p>依赖管理的手段也是保守的。它通过提供一个非常简单的 API 来允许确定性和正确的行为。</p>
<h3 id="Sync-points（同步点）">Sync points（同步点）</h3>
<p><img src="http://img.frankorz.com/5d29bd3e4103143937.png" alt=""></p>
<p>所有结构性的变化都有确切的同步点（hard sync points）。 <code>CreateEntity</code>、<code>Instantiate</code>、 <code>Destroy</code>、 <code>AddComponent</code>、 <code>RemoveComponent</code>、<code>SetSharedComponentData</code> 都有一个确切的同步点。这代表所有通过 <code>JobComponentSystem</code> 排期的 Jobs 都会在创建实体之前自动完成。</p>
<p>例如，在一帧中间的 <code>EntityManager.CreateEntity</code> 可能带来较大的<strong>停滞</strong>，因为所有在世界中的提前排期好的 Jobs 都需要完成。</p>
<p>如果要在游戏中避免上面提到的停滞，可以使用 <code>EntityCommandBuffer</code>。</p>
<h3 id="Multiple-Worlds（多个世界）">Multiple Worlds（多个世界）</h3>
<p>所有世界（World）都有自己的 <code>EntityManager</code> ，因此 <code>JobHandle</code> 依赖句柄的集合都是分开的。一个世界中的确切的同步点（hard sync points）不会影响另外一个世界。因此，对于流式传输和程序化生成的场景，最后在一个世界中创建实体然后移到另一个世界作为一个事务（transaction）并在帧的开始执行。</p>
<p>对于上面的问题可以参考 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/exclusive_entity_transaction.html">ExclusiveEntityTransaction</a> 和 System update order。</p>
<h2 id="Entity-Command-Buffer（实体命令缓冲）">Entity Command Buffer（实体命令缓冲）</h2>
<p><code>EntityCommandBuffer</code> 解决了两个重要问题：</p>
<ol>
<li>在 Job 中无法访问 <code>EntityManager</code>，因此不能通过它来管理实体。</li>
<li>当你使用 <code>EntityManager</code> 时（例如创建一个实体），你会使所有已被注入的数组和 <code>EntityQuery</code> 无效。（这里注入的概念大概是指：系统中可以设定某个过滤条件，给过滤条件加上 <code>[inject]</code> 后，系统会在启动时为这个属性根据条件注入数据，这样就能得到我们想要的数据。会无效是因为你修改了实体数据，那么结果可能会发生改变。）</li>
</ol>
<p><code>EntityCommandBuffer</code> 的抽象允许我们去把需要对数据的更改（changes）排好队，这个更改可以来自主线程或者 Jobs，这样数据可以晚一点在主线程接受更改，从而将其和获取数据分离开来。</p>
<p>我们有两种方法来使用 <code>EntityCommandBuffer</code> ：</p>
<ul>
<li>在主线程 update 的 <code>ComponentSystem</code> 子类有一个 <code>PostUpdateCommands</code>（其本身是一个<code>EntityCommandBuffer</code> ） 可以用，我们只要简单地把变化按顺序放进去即可。在系统的 <code>Update</code> 调用之后，它会立刻自动在世界（World）中进行所有数据更改。这样可以防止数组数据无效，API 也和 <code>EntityManager</code> 很相似。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PostUpdateCommands.CreateEntity(TwoStickBootstrap.BasicEnemyArchetype);</span><br><span class="line">PostUpdateCommands.SetComponent(<span class="keyword">new</span> Position2D &#123; Value = spawnPosition &#125;);</span><br><span class="line">PostUpdateCommands.SetComponent(<span class="keyword">new</span> Heading2D &#123; Value = <span class="keyword">new</span> float2(<span class="number">0.0f</span>, <span class="number">-1.0f</span>) &#125;);</span><br><span class="line">PostUpdateCommands.SetComponent(<span class="literal">default</span>(Enemy));</span><br><span class="line">PostUpdateCommands.SetComponent(<span class="keyword">new</span> Health &#123; Value = TwoStickBootstrap.Settings.enemyInitialHealth &#125;);</span><br><span class="line">PostUpdateCommands.SetComponent(<span class="keyword">new</span> EnemyShootState &#123; Cooldown = <span class="number">0.5f</span> &#125;);</span><br><span class="line">PostUpdateCommands.SetComponent(<span class="keyword">new</span> MoveSpeed &#123; speed = TwoStickBootstrap.Settings.enemySpeed &#125;);</span><br><span class="line">PostUpdateCommands.AddSharedComponent(TwoStickBootstrap.EnemyLook);</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 Jobs 来说，我们必须从主线程的 <code>EntityCommandBufferSystem</code> 中请求一个 <code>EntityCommandBuffer</code>，再传到 Job 里面让其调用。 每当 <code>EntityCommandBufferSystem</code>  进行 update，命令缓冲都会在主线程中重新把更改按创建的顺序执行一遍。这样允许我们集中进行内存管理，也保证了创建的实体和组件的确定性。</li>
</ul>
<h3 id="Entity-Command-Buffer-Systems（实体命令缓冲系统）">Entity Command Buffer Systems（实体命令缓冲系统）</h3>
<p>在一个系统组中，有一个 Entity Command Buffer Systems 运行在所有系统组之前，还有一个运行在所有系统组之后。比较建议的是我们可以用已存在的命令缓存系统（command buffer system）之一，而不用创建自己的，这样可以最小化同步点（sync point）。</p>
<h3 id="在-ParallelFor-jobs-中使用-EntityCommandBuffers">在 ParallelFor jobs 中使用 EntityCommandBuffers</h3>
<p>在 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystemParallelForJobs.html">ParallelFor jobs</a> 使用 <code>EntityCommandBuffer</code> 存 <code>EntityManager</code> 的命令（command）时， <code>EntityCommandBuffer.Concurrent</code> 接口能保证线程安全和确定性的回放（deterministic playback）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See file: /Packages/com.unity.entities/Unity.Entities/EntityCommandBuffer.cs.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Entity <span class="title">CreateEntity</span>(<span class="params"><span class="built_in">int</span> jobIndex, EntityArchetype archetype = <span class="keyword">new</span> EntityArchetype(</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    m_Data-&gt;AddCreateCommand(chain, jobIndex, ECBCommand.CreateEntity,  index, archetype, kBatchableCommand);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Entity &#123;Index = index&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EntityCommandBuffer.Concurrent</code> 的公共方法都会接受一个 <code>jobIndex</code> 参数，这样能回放（playback）已经按顺序保存好的命令。 <code>jobIndex</code> 作为 ID 必须在每个 Job 中唯一。从性能考虑，<code>jobIndex</code> 必须是传进 <code>IJobParallelFor.Execute()</code> 的不断增长的 <code>index</code>。除非你真的知道你传的是啥，否则最安全的做法就是把参数中的 <code>index</code> 作为 <code>jobIndex</code> 传进去。用其他 <code>jobIndex</code> 可能会产生正确的结果，但是可能在某些情况下会有严重的性能影响。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Unity.Jobs</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JobProducerType(typeof (IJobParallelForExtensions.ParallelForJobStruct&lt;&gt;))</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IJobParallelFor</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   <span class="doctag">&lt;para&gt;</span>Implement this method to perform work against a specific iteration index.<span class="doctag">&lt;/para&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;index&quot;&gt;</span>The index of the Parallel for loop at which to perform work.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="System-Update-Order（系统更新顺序）">System Update Order（系统更新顺序）</h2>
<p>组件系统组（Component System Groups）其实是为了解决世界（World）中各种 update 的顺序问题。一个系统组中包含了很多需要按照顺序一起 update 的组件系统（component systems），可以来指定它成员系统（member system）的 update 顺序。</p>
<p>和其他系统一样， <code>ComponentSystemGroup</code> 也继承自 <code>ComponentSystemBase</code> ，因此系统组可以当成一个大的“系统”，里面也用 <code>OnUpdate()</code> 函数来更新系统。它也可以被指定更新的顺序（在某个系统的之前或之后更新等，下文会讲），并且也可以嵌入到其他系统组中。</p>
<p>默认情况下， <code>ComponentSystemGroup</code> 的 <code>OnUpdate()</code> 方法会按照成员系统（member system）的顺序来调用他们的 <code>Update()</code>，如果成员系统也是一个系统组，那么这个系统组也会递归地更新它的成员系统。总体的系统遵循树的深度优先遍历。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See file: /Packages/com.unity.entities/Unity.Entities/ComponentSystemGroup.cs.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_systemSortDirty)</span><br><span class="line">        SortSystemUpdateList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> sys <span class="keyword">in</span> m_systemsToUpdate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            sys.Update();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (World.QuitUpdate)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="System-Ordering-Attributes（系统顺序属性）">System Ordering Attributes（系统顺序属性）</h3>
<ul>
<li><code>[UpdateInGroup]</code> 指定某个系统成为一个 <code>ComponentSystemGroup</code> 中的成员系统。如果没有用这个属性，这个系统会自动被添加到默认世界（default World）的 SimulationSystemGroup 中。</li>
<li><code>[UpdateBefore]</code> 和 <code>[UpdateAfter]</code> 指定系统相对于其他系统的更新顺序。这两个系统必须在同一个系统组（system group）中，前文说到系统组也可以嵌套，因此只要两个系统身处同一个根系统组即可。
<ul>
<li>例子：如果 System A 在 Group A 中、System B 在 Group B 中，而且 Group A 和 Group B 都是 Group C 的成员系统，那么 Group A 和 Group B 的相对顺序也决定着 System A 和 System B 的相对顺序，这时候就不需要明确地用属性标明顺序了。</li>
</ul>
</li>
<li><code>[DisableAutoCreation]</code> 阻止系统从默认的世界初始化中创建或添加到世界中。这时候我们需要显式地创建和更新系统。然而我们也可以把这个系统和它的标记（tag）加到 <code>ComponentSystemGroup</code> 的更新列表中（update list），这样这个系统会正常地自动更新。</li>
</ul>
<h3 id="Default-System-Groups（默认系统组）">Default System Groups（默认系统组）</h3>
<p>默认世界（default World）包含 <code>ComponentSystemGroup</code> 实例的层次结构（hierarchy）。在 Unity Player Loop 中会添加三个根层次（root-level）的系统组。</p>
<p>下图中打开 Entity Debugger，也能看到这三个系统组和其顺序。</p>
<p><img src="http://img.frankorz.com/5d2ab0dd94fe244311.png" alt=""></p>
<p>这三个系统组各司其职， <code>InitializationSystemGroup</code> 做初始化工作， <code>SimulationSystemGroup</code> 在 Update 中做主要的逻辑运算， <code>PresentationSystemGroup</code> 做图形渲染工作。</p>
<p>如果勾选 “Show Full Player Loop” 项，还能看到完整的游戏主循环，以及系统组执行的顺序。</p>
<p><img src="http://img.frankorz.com/5d2acd6b5ea8681591.png" alt=""></p>
<p>下面列表也展示了预定义的系统组和其成员系统：</p>
<ul>
<li>InitializationSystemGroup （在游戏循环（Player Loop）的 <code>Initialization</code> 层最后 update）
<ul>
<li>BeginInitializationEntityCommandBufferSystem</li>
<li>CopyInitialTransformFromGameObjectSystem</li>
<li>SubSceneLiveLinkSystem</li>
<li>SubSceneStreamingSystem</li>
<li>EndInitializationEntityCommandBufferSystem</li>
</ul>
</li>
<li>SimulationSystemGroup（在游戏循环的 <code>Update</code> 层最后 update）
<ul>
<li>BeginSimulationEntityCommandBufferSystem</li>
<li>TransformSystemGroup
<ul>
<li>EndFrameParentSystem</li>
<li>CopyTransformFromGameObjectSystem</li>
<li>EndFrameTRSToLocalToWorldSystem</li>
<li>EndFrameTRSToLocalToParentSystem</li>
<li>EndFrameLocalToParentSystem</li>
<li>CopyTransformToGameObjectSystem</li>
</ul>
</li>
<li>LateSimulationSystemGroup</li>
<li>EndSimulationEntityCommandBufferSystem</li>
</ul>
</li>
<li>PresentationSystemGroup（在游戏循环的 <code>PreLateUpdate</code> 层最后 update）
<ul>
<li>BeginPresentationEntityCommandBufferSystem</li>
<li>CreateMissingRenderBoundsFromMeshRenderer</li>
<li>RenderingSystemBootstrap</li>
<li>RenderBoundsUpdateSystem</li>
<li>RenderMeshSystem</li>
<li>LODGroupSystemV1</li>
<li>LodRequirementsUpdateSystem</li>
<li>EndPresentationEntityCommandBufferSystem</li>
</ul>
</li>
</ul>
<p><strong>P.S. 内容可能在未来有更改</strong></p>
<p>Multiple Worlds（多个世界）</p>
<p>前文多处提到默认的世界，实际上我们可以创建多个世界。同样的组件系统（component system）的类可以在不同的世界中初始化，而且每个实例都可以处于不同的同步点以不同的速度进行update。</p>
<p>当前没有方法手动更新一个世界中的所有系统，但是我们可以控制哪些系统被哪个世界控制，和它们要被加到哪个现存的世界中。自定义的世界可以通过实现 <code>ICustomBootstrap</code> 接口来创建。</p>
<h3 id="Tips-and-Best-Practices（提示与最佳实践）">Tips and Best Practices（提示与最佳实践）</h3>
<ul>
<li>**用 <code>[UpdateInGroup]</code> 为你的系统指定一个 <code>ComponentSystemGroup</code> 系统组。**如果没有用这个属性，这个系统会自动被添加到默认世界（default World）的 SimulationSystemGroup 中。</li>
<li>**用手动更新循环（manually-ticked）的 ComponentSystemGroups 来 update 在主循环中的系统。**添加 <code>[DisableAutoCreation]</code>  阻止系统从默认的世界初始化中创建或添加到世界中。这时候我们可以在主线程中调用 <code>World.GetOrCreateSystem()</code> 来创建系统，调用 <code>MySystem.Update()</code> 来 update 系统。如果你有一个系统要在帧中早点或者晚点运行，这种做法能更简单地把系统插到主循环中。</li>
<li>**尽量使用已存在的 <code>EntityCommandBufferSystem</code> 而不是重新添加一个新的。**因为一个 <code>EntityCommandBufferSystem</code> 代表一个主线程等待子线程完成的同步点（sync point），如果重用一个在每个根系统组（root-level system group）中预定义的 Begin/End 系统，就能节省多个同步点所带来的额外时间间隔（可以回去看同步点小节的示意图，同步点的位置是由最晚执行完的子线程所决定的）。</li>
<li>**避免放自定义的逻辑到 <code>ComponentSystemGroup.OnUpdate()</code> 中。**虽然 <code>ComponentSystemGroup</code> 功能上和一个组件系统（component system）一样，但是我们应该避免这么做。因为它作为一个系统组，在外面不能马上知道成员系统是否已经执行了 update，因此推荐的做法是只让系统组当一个组（group）来用，而把逻辑放到与其分离的组件系统中，再定好该系统与系统组的相对顺序。</li>
</ul>
<h1>最后</h1>
<p>自己才刚考完试，所以计划的文章一直拖到现在。ECS 对我而言充满着吸引力，可能有些程序员也会对性能特别执着吧，它就像魔法一样，完全不同的开发模式，还需要我们深入了解内存的结构。尽管 ECS 可能在工作中对我是一种屠龙技，但有些知识啊，学了就已经很开心了~</p>
<p>我的毕业季也到来了，有空的话可能会写写 Demo 把剩下的实践部分补完，当然计划也可能搁浅。不管怎么样，希望本文对 ECS 同好有所帮助，有问题也欢迎在评论指出。</p>
<h1>参考</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/index.html">《Entity Component System Manual》</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/BrianWill/LearnUnity/tree/master/ecs-jobs">BrianWill LearnUnity/ecs-jobs</a></li>
<li><a target="_blank" rel="noopener" href="https://forum.unity.com/threads/ecs-memory-layout.532028/">《ECS Memory Layout》</a></li>
<li><a target="_blank" rel="noopener" href="https://gametorrahod.com/world-system-groups-update-order-and-the-player-loop/">《World, system groups, update order, and the player loop》</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1vxE61D_N79cvgUI3eIocF2n4rn04wjgRRq00ugyoB1M/edit?usp=sharing">UniteLA 2018 - ECS deep dive</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">猫冬</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://frankorz.com/2019/07/14/clarify-ecs-basic-concept/">http://frankorz.com/2019/07/14/clarify-ecs-basic-concept/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://frankorz.com" target="_blank">萤火之森</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a><a class="post-meta__tags" href="/tags/ECS/">ECS</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-57e27fcf6e91c81d" async="async"></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgswechat-reward.png" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgswechat-reward.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsalipay-reward.jpg" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsalipay-reward.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/04/2019-year-end-summary/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgs2019-year-end-summary.gif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2019 年的收获与成长</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/07/simple-talk-unity-dots/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity DOTS 走马观花</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/07/simple-talk-unity-dots/" title="Unity DOTS 走马观花"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-07</div><div class="title">Unity DOTS 走马观花</div></div></a></div><div><a href="/2020/04/13/2020-04-tech-reading/" title="2020年4月技术导读"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-13</div><div class="title">2020年4月技术导读</div></div></a></div><div><a href="/2020/05/23/2020-05-tech-reading/" title="2020年5月技术导读"><img class="cover" src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsdefault-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-23</div><div class="title">2020年5月技术导读</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgshead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">猫冬</div><div class="author-info__description">各种知识火种~</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Latias94"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Latias94" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:superfrankie621@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://weibo.com/u/1825527674" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到萤火之森🐈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">ECS 与 Job System</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Entities（实体）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BD%93"><span class="toc-number">2.1.</span> <span class="toc-text">创建实体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E5%92%8C%E7%A7%BB%E9%99%A4%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">增加和移除组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">World（世界）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Components（组件）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#General-Purpose-Component%EF%BC%88%E6%99%AE%E9%80%9A%E7%94%A8%E9%80%94%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">General Purpose Component（普通用途组件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shared-components%EF%BC%88%E5%85%B1%E4%BA%AB%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">Shared components（共享组件）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%A6%81%E7%82%B9"><span class="toc-number">4.2.2.</span> <span class="toc-text">其他要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-state-components%EF%BC%88%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">System state components（系统状态组件）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Motivation%EF%BC%88%E8%AF%B1%E5%9B%A0%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">Motivation（诱因）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Concept%EF%BC%88%E6%A6%82%E5%BF%B5%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">Concept（概念）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B7%BB%E5%8A%A0"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">检测组件的添加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">检测组件的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%B5%8B%E5%AE%9E%E4%BD%93%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">监测实体的删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dynamic-Buffers%EF%BC%88%E5%8A%A8%E6%80%81%E7%BC%93%E5%86%B2%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">Dynamic Buffers（动态缓冲）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BC%93%E5%86%B2"><span class="toc-number">4.4.1.</span> <span class="toc-text">定义缓冲</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">Systems（系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ComponentSystem%EF%BC%88%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">ComponentSystem（组件系统）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JobComponentSystem%EF%BC%88%E4%BB%BB%E5%8A%A1%E7%BB%84%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">JobComponentSystem（任务组件系统）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84-Job-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">自动化的 Job 依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">怎么运行的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E6%98%AF%E4%BF%9D%E5%AE%88%E7%9A%84%EF%BC%88conservative%EF%BC%89%E5%92%8C%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%EF%BC%88deterministic%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">依赖管理是保守的（conservative）和确定性的（deterministic）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sync-points%EF%BC%88%E5%90%8C%E6%AD%A5%E7%82%B9%EF%BC%89"><span class="toc-number">5.2.4.</span> <span class="toc-text">Sync points（同步点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiple-Worlds%EF%BC%88%E5%A4%9A%E4%B8%AA%E4%B8%96%E7%95%8C%EF%BC%89"><span class="toc-number">5.2.5.</span> <span class="toc-text">Multiple Worlds（多个世界）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity-Command-Buffer%EF%BC%88%E5%AE%9E%E4%BD%93%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">Entity Command Buffer（实体命令缓冲）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Entity-Command-Buffer-Systems%EF%BC%88%E5%AE%9E%E4%BD%93%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">Entity Command Buffer Systems（实体命令缓冲系统）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-ParallelFor-jobs-%E4%B8%AD%E4%BD%BF%E7%94%A8-EntityCommandBuffers"><span class="toc-number">5.3.2.</span> <span class="toc-text">在 ParallelFor jobs 中使用 EntityCommandBuffers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Update-Order%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E9%A1%BA%E5%BA%8F%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">System Update Order（系统更新顺序）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Ordering-Attributes%EF%BC%88%E7%B3%BB%E7%BB%9F%E9%A1%BA%E5%BA%8F%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-number">5.4.1.</span> <span class="toc-text">System Ordering Attributes（系统顺序属性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Default-System-Groups%EF%BC%88%E9%BB%98%E8%AE%A4%E7%B3%BB%E7%BB%9F%E7%BB%84%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">Default System Groups（默认系统组）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tips-and-Best-Practices%EF%BC%88%E6%8F%90%E7%A4%BA%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%89"><span class="toc-number">5.4.3.</span> <span class="toc-text">Tips and Best Practices（提示与最佳实践）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/rust-study-resource/" title="Rust 学习资源"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsrust-study-resource-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Rust 学习资源"/></a><div class="content"><a class="title" href="/2022/01/18/rust-study-resource/" title="Rust 学习资源">Rust 学习资源</a><time datetime="2022-01-18T14:01:44.000Z" title="发表于 2022-01-18 14:01:44">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/05/rust-raytrace/" title="用 Rust 实现简单的光线追踪"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsrust-raytrace-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用 Rust 实现简单的光线追踪"/></a><div class="content"><a class="title" href="/2021/05/05/rust-raytrace/" title="用 Rust 实现简单的光线追踪">用 Rust 实现简单的光线追踪</a><time datetime="2021-05-05T00:48:30.000Z" title="发表于 2021-05-05 00:48:30">2021-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/18/learn-pixel-art/" title="24 天像素画从入门到放弃"><img src="http://img.frankorz.com/day23-dog-in-snow.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24 天像素画从入门到放弃"/></a><div class="content"><a class="title" href="/2021/04/18/learn-pixel-art/" title="24 天像素画从入门到放弃">24 天像素画从入门到放弃</a><time datetime="2021-04-18T12:33:30.000Z" title="发表于 2021-04-18 12:33:30">2021-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/17/compute-shader/" title="Compute Shader 简介"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgscompute-shader-cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Compute Shader 简介"/></a><div class="content"><a class="title" href="/2021/04/17/compute-shader/" title="Compute Shader 简介">Compute Shader 简介</a><time datetime="2021-04-17T22:14:30.000Z" title="发表于 2021-04-17 22:14:30">2021-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/10/03/add-note-section-to-blog/" title="博客新增公开笔记部分"><img src="https://cdn.jsdelivr.net/gh/latias94/blog-images@main/top/frankorz/blog/imgsadd-note-section-to-blog-cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="博客新增公开笔记部分"/></a><div class="content"><a class="title" href="/2020/10/03/add-note-section-to-blog/" title="博客新增公开笔记部分">博客新增公开笔记部分</a><time datetime="2020-10-03T15:53:30.000Z" title="发表于 2020-10-03 15:53:30">2020-10-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 猫冬</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="beian.miit.gov.cn"><span>粤ICP备19098175号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'http://frankorz.com/2019/07/14/clarify-ecs-basic-concept/'
    this.page.identifier = '2019/07/14/clarify-ecs-basic-concept/'
    this.page.title = '洞明 Unity ECS 基础概念'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://frankorz.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>